diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/i2c.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/i2c.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/i2c.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/i2c.c	2015-01-10 16:29:03.266519676 +0530
@@ -0,0 +1,454 @@
+/*
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, d.mueller@elsoft.ch
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This code should work for both the S3C2400 and the S3C2410
+ * as they seem to have the same I2C controller inside.
+ * The different address mapping is handled by the s3c24xx.h files below.
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_DRIVER_S3C24X0_I2C
+
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#include <s3c2440.h>
+#endif
+#include <i2c.h>
+
+#ifdef CONFIG_HARD_I2C
+
+#define	I2C_WRITE	0
+#define I2C_READ	1
+
+#define I2C_OK		0
+#define I2C_NOK		1
+#define I2C_NACK	2
+#define I2C_NOK_LA	3		/* Lost arbitration */
+#define I2C_NOK_TOUT	4		/* time out */
+
+#define I2CSTAT_BSY	0x20		/* Busy bit */
+#define I2CSTAT_NACK	0x01		/* Nack bit */
+#define I2CCON_IRPND	0x10		/* Interrupt pending bit */
+#define I2C_MODE_MT	0xC0		/* Master Transmit Mode */
+#define I2C_MODE_MR	0x80		/* Master Receive Mode */
+#define I2C_START_STOP	0x20		/* START / STOP */
+#define I2C_TXRX_ENA	0x10		/* I2C Tx/Rx enable */
+
+#define I2C_TIMEOUT 1			/* 1 second */
+
+
+static int GetI2CSDA(void)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440) || \
+    defined(CONFIG_S3C2442)
+	return (gpio->GPEDAT & 0x8000) >> 15;
+#endif
+#ifdef CONFIG_S3C2400
+	return (gpio->PGDAT & 0x0020) >> 5;
+#endif
+}
+
+#if 0
+static void SetI2CSDA(int x)
+{
+	rGPEDAT = (rGPEDAT & ~0x8000) | (x&1) << 15;
+}
+#endif
+
+static void SetI2CSCL(int x)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440) || \
+    defined(CONFIG_S3C2442)
+	gpio->GPEDAT = (gpio->GPEDAT & ~0x4000) | (x&1) << 14;
+#endif
+#ifdef CONFIG_S3C2400
+	gpio->PGDAT = (gpio->PGDAT & ~0x0040) | (x&1) << 6;
+#endif
+}
+
+
+static int WaitForXfer (void)
+{
+	S3C24X0_I2C *const i2c = S3C24X0_GetBase_I2C ();
+	int i, status;
+
+	i = I2C_TIMEOUT * 10000;
+	status = i2c->IICCON;
+	while ((i > 0) && !(status & I2CCON_IRPND)) {
+		udelay (100);
+		status = i2c->IICCON;
+		i--;
+	}
+
+	return (status & I2CCON_IRPND) ? I2C_OK : I2C_NOK_TOUT;
+}
+
+static int IsACK (void)
+{
+	S3C24X0_I2C *const i2c = S3C24X0_GetBase_I2C ();
+
+	return (!(i2c->IICSTAT & I2CSTAT_NACK));
+}
+
+static void ReadWriteByte (void)
+{
+	S3C24X0_I2C *const i2c = S3C24X0_GetBase_I2C ();
+
+	i2c->IICCON &= ~I2CCON_IRPND;
+}
+
+void i2c_init (int speed, int slaveadd)
+{
+	S3C24X0_I2C *const i2c = S3C24X0_GetBase_I2C ();
+	S3C24X0_GPIO *const gpio = S3C24X0_GetBase_GPIO ();
+	ulong freq, pres = 16, div;
+	int i, status;
+
+	/* wait for some time to give previous transfer a chance to finish */
+
+	i = I2C_TIMEOUT * 1000;
+	status = i2c->IICSTAT;
+	while ((i > 0) && (status & I2CSTAT_BSY)) {
+		udelay (1000);
+		status = i2c->IICSTAT;
+		i--;
+	}
+
+	if ((status & I2CSTAT_BSY) || GetI2CSDA () == 0) {
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440) || \
+    defined(CONFIG_S3C2442)
+		ulong old_gpecon = gpio->GPECON;
+#endif
+#ifdef CONFIG_S3C2400
+		ulong old_gpecon = gpio->PGCON;
+#endif
+		/* bus still busy probably by (most) previously interrupted transfer */
+
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440) || \
+    defined(CONFIG_S3C2442)
+		/* set I2CSDA and I2CSCL (GPE15, GPE14) to GPIO */
+		gpio->GPECON = (gpio->GPECON & ~0xF0000000) | 0x10000000;
+#endif
+#ifdef CONFIG_S3C2400
+		/* set I2CSDA and I2CSCL (PG5, PG6) to GPIO */
+		gpio->PGCON = (gpio->PGCON & ~0x00003c00) | 0x00001000;
+#endif
+
+		/* toggle I2CSCL until bus idle */
+		SetI2CSCL (0);
+		udelay (1000);
+		i = 10;
+		while ((i > 0) && (GetI2CSDA () != 1)) {
+			SetI2CSCL (1);
+			udelay (1000);
+			SetI2CSCL (0);
+			udelay (1000);
+			i--;
+		}
+		SetI2CSCL (1);
+		udelay (1000);
+
+		/* restore pin functions */
+#if defined(CONFIG_S3C2410) || defined(CONFIG_S3C2440) || \
+    defined(CONFIG_S3C2442)
+		gpio->GPECON = old_gpecon;
+#endif
+#ifdef CONFIG_S3C2400
+		gpio->PGCON = old_gpecon;
+#endif
+	}
+
+	/* calculate prescaler and divisor values */
+	freq = get_PCLK ();
+	if ((freq / pres / (16 + 1)) > speed)
+		/* set prescaler to 512 */
+		pres = 512;
+
+	div = 0;
+	while ((freq / pres / (div + 1)) > speed)
+		div++;
+
+	/* set prescaler, divisor according to freq, also set
+	 * ACKGEN, IRQ */
+	i2c->IICCON = (div & 0x0F) | 0xA0 | ((pres == 512) ? 0x40 : 0);
+
+	/* init to SLAVE REVEIVE and set slaveaddr */
+	i2c->IICSTAT = 0;
+	i2c->IICADD = slaveadd;
+	/* program Master Transmit (and implicit STOP) */
+	i2c->IICSTAT = I2C_MODE_MT | I2C_TXRX_ENA;
+
+}
+
+/*
+ * cmd_type is 0 for write, 1 for read.
+ *
+ * addr_len can take any value from 0-255, it is only limited
+ * by the char, we could make it larger if needed. If it is
+ * 0 we skip the address write cycle.
+ */
+static
+int i2c_transfer (unsigned char cmd_type,
+		  unsigned char chip,
+		  unsigned char addr[],
+		  unsigned char addr_len,
+		  unsigned char data[], unsigned short data_len)
+{
+	S3C24X0_I2C *const i2c = S3C24X0_GetBase_I2C ();
+	int i, status, result;
+
+	if (data == 0 || data_len == 0) {
+		/*Don't support data transfer of no length or to address 0 */
+		printf ("i2c_transfer: bad call\n");
+		return I2C_NOK;
+	}
+
+	/* Check I2C bus idle */
+	i = I2C_TIMEOUT * 1000;
+	status = i2c->IICSTAT;
+	while ((i > 0) && (status & I2CSTAT_BSY)) {
+		udelay (1000);
+		status = i2c->IICSTAT;
+		i--;
+	}
+
+	if (status & I2CSTAT_BSY)
+		return I2C_NOK_TOUT;
+
+	i2c->IICCON |= 0x80;
+	result = I2C_OK;
+
+	switch (cmd_type) {
+	case I2C_WRITE:
+		if (addr && addr_len) {
+			i2c->IICDS = chip;
+			/* send START */
+			i2c->IICSTAT = I2C_MODE_MT | I2C_TXRX_ENA | I2C_START_STOP;
+			i = 0;
+			while ((i < addr_len) && (result == I2C_OK)) {
+				result = WaitForXfer ();
+				i2c->IICDS = addr[i];
+				ReadWriteByte ();
+				i++;
+			}
+			i = 0;
+			while ((i < data_len) && (result == I2C_OK)) {
+				result = WaitForXfer ();
+				i2c->IICDS = data[i];
+				ReadWriteByte ();
+				i++;
+			}
+		} else {
+			i2c->IICDS = chip;
+			/* send START */
+			i2c->IICSTAT = I2C_MODE_MT | I2C_TXRX_ENA | I2C_START_STOP;
+			i = 0;
+			while ((i < data_len) && (result = I2C_OK)) {
+				result = WaitForXfer ();
+				i2c->IICDS = data[i];
+				ReadWriteByte ();
+				i++;
+			}
+		}
+
+		if (result == I2C_OK)
+			result = WaitForXfer ();
+
+		/* send STOP */
+		i2c->IICSTAT = I2C_MODE_MR | I2C_TXRX_ENA;
+		ReadWriteByte ();
+		break;
+
+	case I2C_READ:
+		if (addr && addr_len) {
+			i2c->IICSTAT = I2C_MODE_MT | I2C_TXRX_ENA;
+			i2c->IICDS = chip;
+			/* send START */
+			i2c->IICSTAT |= I2C_START_STOP;
+			result = WaitForXfer ();
+			if (IsACK ()) {
+				i = 0;
+				while ((i < addr_len) && (result == I2C_OK)) {
+					i2c->IICDS = addr[i];
+					ReadWriteByte ();
+					result = WaitForXfer ();
+					i++;
+				}
+
+				i2c->IICDS = chip;
+				/* resend START */
+				i2c->IICSTAT =  I2C_MODE_MR | I2C_TXRX_ENA |
+						I2C_START_STOP;
+				ReadWriteByte ();
+				result = WaitForXfer ();
+				i = 0;
+				while ((i < data_len) && (result == I2C_OK)) {
+					/* disable ACK for final READ */
+					if (i == data_len - 1)
+						i2c->IICCON &= ~0x80;
+					ReadWriteByte ();
+					result = WaitForXfer ();
+					data[i] = i2c->IICDS;
+					i++;
+				}
+			} else {
+				result = I2C_NACK;
+			}
+
+		} else {
+			i2c->IICSTAT = I2C_MODE_MR | I2C_TXRX_ENA;
+			i2c->IICDS = chip;
+			/* send START */
+			i2c->IICSTAT |= I2C_START_STOP;
+			result = WaitForXfer ();
+
+			if (IsACK ()) {
+				i = 0;
+				while ((i < data_len) && (result == I2C_OK)) {
+					/* disable ACK for final READ */
+					if (i == data_len - 1)
+						i2c->IICCON &= ~0x80;
+					ReadWriteByte ();
+					result = WaitForXfer ();
+					data[i] = i2c->IICDS;
+					i++;
+				}
+			} else {
+				result = I2C_NACK;
+			}
+		}
+
+		/* send STOP */
+		i2c->IICSTAT = I2C_MODE_MR | I2C_TXRX_ENA;
+		ReadWriteByte ();
+		break;
+
+	default:
+		printf ("i2c_transfer: bad call\n");
+		result = I2C_NOK;
+		break;
+	}
+
+	return (result);
+}
+
+int i2c_probe (uchar chip)
+{
+	uchar buf[1];
+
+	buf[0] = 0;
+
+	/*
+	 * What is needed is to send the chip address and verify that the
+	 * address was <ACK>ed (i.e. there was a chip at that address which
+	 * drove the data line low).
+	 */
+	return (i2c_transfer (I2C_READ, chip << 1, 0, 0, buf, 1) != I2C_OK);
+}
+
+int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	uchar xaddr[4];
+	int ret;
+
+	if (alen > 4) {
+		printf ("I2C read: addr len %d not supported\n", alen);
+		return 1;
+	}
+
+	if (alen > 0) {
+		xaddr[0] = (addr >> 24) & 0xFF;
+		xaddr[1] = (addr >> 16) & 0xFF;
+		xaddr[2] = (addr >> 8) & 0xFF;
+		xaddr[3] = addr & 0xFF;
+	}
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	/*
+	 * EEPROM chips that implement "address overflow" are ones
+	 * like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	 * address and the extra bits end up in the "chip address"
+	 * bit slots. This makes a 24WC08 (1Kbyte) chip look like
+	 * four 256 byte chips.
+	 *
+	 * Note that we consider the length of the address field to
+	 * still be one byte because the extra address bits are
+	 * hidden in the chip address.
+	 */
+	if (alen > 0)
+		chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+#endif
+	if ((ret =
+	     i2c_transfer (I2C_READ, chip << 1, &xaddr[4 - alen], alen,
+			   buffer, len)) != 0) {
+		printf ("I2c read: failed %d\n", ret);
+		return 1;
+	}
+	return 0;
+}
+
+int i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	uchar xaddr[4];
+
+	if (alen > 4) {
+		printf ("I2C write: addr len %d not supported\n", alen);
+		return 1;
+	}
+
+	if (alen > 0) {
+		xaddr[0] = (addr >> 24) & 0xFF;
+		xaddr[1] = (addr >> 16) & 0xFF;
+		xaddr[2] = (addr >> 8) & 0xFF;
+		xaddr[3] = addr & 0xFF;
+	}
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	/*
+	 * EEPROM chips that implement "address overflow" are ones
+	 * like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	 * address and the extra bits end up in the "chip address"
+	 * bit slots. This makes a 24WC08 (1Kbyte) chip look like
+	 * four 256 byte chips.
+	 *
+	 * Note that we consider the length of the address field to
+	 * still be one byte because the extra address bits are
+	 * hidden in the chip address.
+	 */
+	if (alen > 0)
+		chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+#endif
+	return (i2c_transfer
+		(I2C_WRITE, chip << 1, &xaddr[4 - alen], alen, buffer,
+		 len) != 0);
+}
+#endif	/* CONFIG_HARD_I2C */
+
+#endif /* CONFIG_DRIVER_S3C24X0_I2C */
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/Makefile u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/Makefile
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/Makefile	2014-04-15 00:49:24.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/Makefile	2015-01-10 16:33:44.094516520 +0530
@@ -9,3 +9,11 @@ obj-$(CONFIG_USE_IRQ) += interrupts.o
 obj-$(CONFIG_DISPLAY_CPUINFO)	+= cpu_info.o
 obj-y	+= speed.o
 obj-y	+= timer.o
+obj-y   += i2c.o
+obj-y   += serial.o
+obj-y   += usb.o
+obj-y   += usb_ohci.o
+obj-y   += nand_read.o
+obj-y   += nand.o
+obj-y   += cmd_s3c24xx.o
+obj-y   += mmc.o
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/mmc.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/mmc.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/mmc.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/mmc.c	2015-01-10 16:29:14.486519550 +0530
@@ -0,0 +1,600 @@
+/*
+ * u-boot S3C2410 MMC/SD card driver
+ * (C) Copyright 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * based on u-boot pxa MMC driver and linux/drivers/mmc/s3c2410mci.c
+ * (C) 2005-2005 Thomas Kleffel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <s3c2410.h>
+#include <part.h>
+#include <fat.h>
+
+#if defined(CONFIG_MMC) && defined(CONFIG_MMC_S3C)
+
+#ifdef DEBUG
+#define pr_debug(fmt, args...) printf(fmt, ##args)
+#else
+#define pr_debug(...) do { } while(0)
+#endif
+
+#define CONFIG_MMC_WIDE
+
+static S3C2410_SDI *sdi;
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static mmc_csd_t mmc_csd;
+static int mmc_ready = 0;
+static int wide = 0;
+
+
+#define CMD_F_RESP	0x01
+#define CMD_F_RESP_LONG	0x02
+
+#define CMD_F_RESP_R7 CMD_F_RESP
+
+static u_int32_t *mmc_cmd(ushort cmd, ulong arg, ushort flags)
+{
+	static u_int32_t resp[5];
+
+	u_int32_t ccon, csta;
+	u_int32_t csta_rdy_bit = S3C2410_SDICMDSTAT_CMDSENT;
+
+	memset(resp, 0, sizeof(resp));
+
+	debug("mmc_cmd CMD%d arg=0x%08x flags=%x\n", cmd, arg, flags);
+
+	sdi->SDICSTA = 0xffffffff;
+	sdi->SDIDSTA = 0xffffffff;
+	sdi->SDIFSTA = 0xffffffff;
+
+	sdi->SDICARG = arg;
+
+	ccon = cmd & S3C2410_SDICMDCON_INDEX;
+	ccon |= S3C2410_SDICMDCON_SENDERHOST|S3C2410_SDICMDCON_CMDSTART;
+
+	if (flags & CMD_F_RESP) {
+		ccon |= S3C2410_SDICMDCON_WAITRSP;
+		csta_rdy_bit = S3C2410_SDICMDSTAT_RSPFIN; /* 1 << 9 */
+	}
+
+	if (flags & CMD_F_RESP_LONG)
+		ccon |= S3C2410_SDICMDCON_LONGRSP;
+
+	sdi->SDICCON = ccon;
+
+	while (1) {
+		csta = sdi->SDICSTA;
+		if (csta & csta_rdy_bit)
+			break;
+		if (csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {
+			printf("===============> MMC CMD Timeout\n");
+			sdi->SDICSTA |= S3C2410_SDICMDSTAT_CMDTIMEOUT;
+			break;
+		}
+	}
+
+	debug("final MMC CMD status 0x%x\n", csta);
+
+	sdi->SDICSTA |= csta_rdy_bit;
+
+	if (flags & CMD_F_RESP) {
+		resp[0] = sdi->SDIRSP0;
+		resp[1] = sdi->SDIRSP1;
+		resp[2] = sdi->SDIRSP2;
+		resp[3] = sdi->SDIRSP3;
+	}
+
+	return resp;
+}
+
+#define FIFO_FILL(host) ((host->SDIFSTA & S3C2410_SDIFSTA_COUNTMASK) >> 2)
+
+static int mmc_block_read(uchar *dst, ulong src, ulong len)
+{
+	u_int32_t dcon, fifo;
+	u_int32_t *dst_u32 = (u_int32_t *)dst;
+	u_int32_t *resp;
+
+	if (len == 0)
+		return 0;
+
+	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong)dst, src, len);
+
+	/* set block len */
+	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, len, CMD_F_RESP);
+	sdi->SDIBSIZE = len;
+
+	//sdi->SDIPRE = 0xff;
+
+	/* setup data */
+	dcon = (len >> 9) & S3C2410_SDIDCON_BLKNUM;
+	dcon |= S3C2410_SDIDCON_BLOCKMODE;
+	dcon |= S3C2410_SDIDCON_RXAFTERCMD|S3C2410_SDIDCON_XFER_RXSTART;
+	if (wide)
+		dcon |= S3C2410_SDIDCON_WIDEBUS;
+#if defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	dcon |= S3C2440_SDIDCON_DS_WORD | S3C2440_SDIDCON_DATSTART;
+#endif
+	sdi->SDIDCON = dcon;
+
+	/* send read command */
+	resp = mmc_cmd(MMC_CMD_READ_BLOCK, (mmc_dev.if_type == IF_TYPE_SDHC) ? (src >> 9) : src, CMD_F_RESP);
+
+	while (len > 0) {
+		u_int32_t sdidsta = sdi->SDIDSTA;
+		fifo = FIFO_FILL(sdi);
+		if (sdidsta & (S3C2410_SDIDSTA_FIFOFAIL|
+				S3C2410_SDIDSTA_CRCFAIL|
+				S3C2410_SDIDSTA_RXCRCFAIL|
+				S3C2410_SDIDSTA_DATATIMEOUT)) {
+			printf("mmc_block_read: err SDIDSTA=0x%08x\n", sdidsta);
+			return -EIO;
+		}
+
+		while (fifo--) {
+			//debug("dst_u32 = 0x%08x\n", dst_u32);
+			*(dst_u32++) = sdi->SDIDAT;
+			if (len >= 4)
+				len -= 4;
+			else {
+				len = 0;
+				break;
+			}
+		}
+	}
+
+	debug("waiting for SDIDSTA  (currently 0x%08x\n", sdi->SDIDSTA);
+	while (!(sdi->SDIDSTA & (1 << 4))) {}
+	debug("done waiting for SDIDSTA (currently 0x%08x\n", sdi->SDIDSTA);
+
+	sdi->SDIDCON = 0;
+
+	if (!(sdi->SDIDSTA & S3C2410_SDIDSTA_XFERFINISH))
+		debug("mmc_block_read; transfer not finished!\n");
+
+	return 0;
+}
+
+static int mmc_block_write(ulong dst, uchar *src, int len)
+{
+	printf("MMC block write not yet supported on S3C2410!\n");
+	return -1;
+}
+
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0)
+		return 0;
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0)
+			return -1;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && src < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0)
+		return 0;
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0)
+			return -1;
+
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0)
+			return -1;
+
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0)
+			return -1;
+
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0)
+			return -1;
+
+	}
+	return 0;
+}
+
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, void *dst)
+{
+	int mmc_block_size = MMC_BLOCK_SIZE;
+	ulong src = blknr * mmc_block_size + CFG_MMC_BASE;
+
+	mmc_read(src, dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+/* MMC_DEFAULT_RCA should probably be just 1, but this may break other code
+   that expects it to be shifted. */
+static u_int16_t rca = MMC_DEFAULT_RCA >> 16;
+
+static u_int32_t mmc_size(const struct mmc_csd *csd)
+{
+	u_int32_t block_len, mult, blocknr;
+
+	block_len = csd->read_bl_len << 12;
+	mult = csd->c_size_mult1 << 8;
+	blocknr = (csd->c_size+1) * mult;
+
+	return blocknr * block_len;
+}
+
+struct sd_cid {
+	char		pnm_0;	/* product name */
+	char		oid_1;	/* OEM/application ID */
+	char		oid_0;
+	uint8_t		mid;	/* manufacturer ID */
+	char		pnm_4;
+	char		pnm_3;
+	char		pnm_2;
+	char		pnm_1;
+	uint8_t		psn_2;	/* product serial number */
+	uint8_t		psn_1;
+	uint8_t		psn_0;	/* MSB */
+	uint8_t		prv;	/* product revision */
+	uint8_t		crc;	/* CRC7 checksum, b0 is unused and set to 1 */
+	uint8_t		mdt_1;	/* manufacturing date, LSB, RRRRyyyy yyyymmmm */
+	uint8_t		mdt_0;	/* MSB */
+	uint8_t		psn_3;	/* LSB */
+};
+
+static void print_mmc_cid(mmc_cid_t *cid)
+{
+	printf("MMC found. Card desciption is:\n");
+	printf("Manufacturer ID = %02x%02x%02x\n",
+		cid->id[0], cid->id[1], cid->id[2]);
+	printf("HW/FW Revision = %x %x\n",cid->hwrev, cid->fwrev);
+	cid->hwrev = cid->fwrev = 0;	/* null terminate string */
+	printf("Product Name = %s\n",cid->name);
+	printf("Serial Number = %02x%02x%02x\n",
+		cid->sn[0], cid->sn[1], cid->sn[2]);
+	printf("Month = %d\n",cid->month);
+	printf("Year = %d\n",1997 + cid->year);
+}
+
+static void print_sd_cid(const struct sd_cid *cid)
+{
+	printf("Manufacturer:       0x%02x, OEM \"%c%c\"\n",
+	    cid->mid, cid->oid_0, cid->oid_1);
+	printf("Product name:       \"%c%c%c%c%c\", revision %d.%d\n",
+	    cid->pnm_0, cid->pnm_1, cid->pnm_2, cid->pnm_3, cid->pnm_4,
+	    cid->prv >> 4, cid->prv & 15);
+	printf("Serial number:      %u\n",
+	    cid->psn_0 << 24 | cid->psn_1 << 16 | cid->psn_2 << 8 |
+	    cid->psn_3);
+	printf("Manufacturing date: %d/%d\n",
+	    cid->mdt_1 & 15,
+	    2000+((cid->mdt_0 & 15) << 4)+((cid->mdt_1 & 0xf0) >> 4));
+	printf("CRC:                0x%02x, b0 = %d\n",
+	    cid->crc >> 1, cid->crc & 1);
+}
+
+int mmc_init(int verbose)
+{
+ 	int retries, rc = -ENODEV;
+	int is_sd = 0;
+	u_int32_t *resp;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	block_dev_desc_t *mmc_blkdev_p = &mmc_dev;
+
+	sdi = S3C2410_GetBase_SDI();
+
+	debug("mmc_init(PCLK=%u)\n", get_PCLK());
+
+	clk_power->CLKCON |= (1 << 9);
+
+	sdi->SDIBSIZE = 512;
+#if defined(CONFIG_S3C2410)
+	/* S3C2410 has some bug that prevents reliable operation at higher speed */
+	//sdi->SDIPRE = 0x3e;  /* SDCLK = PCLK/2 / (SDIPRE+1) = 396kHz */
+	sdi->SDIPRE = 0x02;  /* 2410: SDCLK = PCLK/2 / (SDIPRE+1) = 11MHz */
+	sdi->SDIDTIMER = 0xffff;
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	sdi->SDIPRE = 0x05;  /* 2410: SDCLK = PCLK / (SDIPRE+1) = 11MHz */
+	sdi->SDIDTIMER = 0x7fffff;
+#endif
+	sdi->SDIIMSK = 0x0;
+	sdi->SDICON = S3C2410_SDICON_FIFORESET|S3C2410_SDICON_CLOCKTYPE;
+	udelay(125000); /* FIXME: 74 SDCLK cycles */
+
+	mmc_csd.c_size = 0;
+
+	/* reset */
+	retries = 10;
+	resp = mmc_cmd(MMC_CMD_RESET, 0, 0);
+
+	mmc_dev.if_type = IF_TYPE_UNKNOWN;
+	if(verbose)
+		puts("mmc: Probing for SDHC ...\n");
+
+	/* Send supported voltage range */
+	/* SD cards 1.x do not answer to CMD8 */
+        resp = mmc_cmd(MMC_CMD_IF_COND, ((1 << 8) | 0xAA), CMD_F_RESP_R7);
+        if (!resp[0]) {
+             /*
+              * ARC: No answer let's try SD 1.x
+              */
+             if(verbose)
+                     puts("mmc: No answer to CMD8 trying SD\n");
+             mmc_blkdev_p->if_type = IF_TYPE_SD;
+        } else {
+             /*
+              * ARC: probably an SDHC card
+              */
+             mmc_blkdev_p->if_type = IF_TYPE_SDHC;
+             if(verbose)
+                     puts("mmc: SD 2.0 or later card found\n");
+
+             /* Check if the card supports this voltage */
+             if (resp[0] != ((1 << 8) | 0xAA)) {
+                     pr_debug("mmc: Invalid voltage range\n");
+                     return -ENODEV;
+             }
+        }
+
+	/*
+	 * ARC: HC (30) bit set according to response to
+	 * CMD8 command
+	 */
+
+	pr_debug("mmc: Sending ACMD41 %s HC set\n",
+		         ((mmc_blkdev_p->if_type ==
+		           IF_TYPE_SDHC) ? "with" : "without"));
+
+	printf("trying to detect SD Card...\n");
+	while (retries--) {
+		udelay(100000);
+		resp = mmc_cmd(55, 0x00000000, CMD_F_RESP);
+		resp = mmc_cmd(41, (mmc_blkdev_p->if_type == IF_TYPE_SDHC)? (0x00300000 | (1<<30)) : 0x00300000, CMD_F_RESP);
+
+		if (resp[0] & (1 << 31)) {
+			is_sd = 1;
+			break;
+		}
+	}
+
+	/*
+	* ARC: check for HC bit, if its not set
+	* sd card is SD
+	*/
+	if (is_sd && (resp[0] & 0xc0000000) == 0x80000000) {
+	       mmc_dev.if_type = IF_TYPE_SD;
+	}
+
+	if (retries == 0 && !is_sd) {
+		retries = 10;
+		printf("failed to detect SD Card, trying MMC\n");
+		mmc_blkdev_p->if_type = IF_TYPE_MMC;
+		resp = mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ffc000, CMD_F_RESP);
+		while (retries-- && resp && !(resp[4] & 0x80)) {
+			debug("resp %x %x\n", resp[0], resp[1]);
+			udelay(50);
+			resp = mmc_cmd(1, 0x00ffff00, CMD_F_RESP);
+		}
+	}
+
+	/* try to get card id */
+	resp = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, CMD_F_RESP|CMD_F_RESP_LONG);
+	if (resp) {
+		if (!is_sd) {
+			/* TODO configure mmc driver depending on card
+			   attributes */
+			mmc_cid_t *cid = (mmc_cid_t *)resp;
+
+			if (verbose)
+				print_mmc_cid(cid);
+			sprintf((char *) mmc_dev.vendor,
+				"Man %02x%02x%02x Snr %02x%02x%02x",
+				cid->id[0], cid->id[1], cid->id[2],
+				cid->sn[0], cid->sn[1], cid->sn[2]);
+			sprintf((char *) mmc_dev.product,"%s",cid->name);
+			sprintf((char *) mmc_dev.revision,"%x %x",
+				cid->hwrev, cid->fwrev);
+		}
+		else {
+			struct sd_cid *cid = (struct sd_cid *) resp;
+
+			if (verbose)
+				print_sd_cid(cid);
+			sprintf((char *) mmc_dev.vendor,
+			    "Man %02 OEM %c%c \"%c%c%c%c%c\"",
+			    cid->mid, cid->oid_0, cid->oid_1,
+			    cid->pnm_0, cid->pnm_1, cid->pnm_2, cid->pnm_3,
+			    cid->pnm_4);
+			sprintf((char *) mmc_dev.product, "%d",
+			    cid->psn_0 << 24 | cid->psn_1 << 16 |
+			    cid->psn_2 << 8 | cid->psn_3);
+			sprintf((char *) mmc_dev.revision, "%d.%d",
+			    cid->prv >> 4, cid->prv & 15);
+		}
+
+		/* fill in device description */
+		if (mmc_dev.if_type == IF_TYPE_UNKNOWN)
+			mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		mmc_dev.removable = 0;
+		mmc_dev.block_read = mmc_bread;
+
+		/* MMC exists, get CSD too */
+		resp = mmc_cmd(MMC_CMD_SET_RCA, MMC_DEFAULT_RCA, CMD_F_RESP);
+		if (is_sd)
+			rca = resp[0] >> 16;
+
+		resp = mmc_cmd(MMC_CMD_SEND_CSD, rca<<16, CMD_F_RESP|CMD_F_RESP_LONG);
+		if (resp) {
+			mmc_csd_t *csd = (mmc_csd_t *)resp;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			rc = 0;
+			mmc_ready = 1;
+			/* FIXME add verbose printout for csd */
+			printf("READ_BL_LEN=%u, C_SIZE_MULT=%u, C_SIZE=%u\n",
+				csd->read_bl_len, csd->c_size_mult1, csd->c_size);
+			printf("size = %u\n", mmc_size(csd));
+		}
+	}
+
+	resp = mmc_cmd(MMC_CMD_SELECT_CARD, rca<<16, CMD_F_RESP);
+
+	if (verbose)
+	       printf("SD Card detected RCA: 0x%x type: %s\n",
+	              rca, ((mmc_dev.if_type == IF_TYPE_SDHC) ? "SDHC" : ((mmc_dev.if_type == IF_TYPE_SD) ? "SD" : "MMC")));
+
+#ifdef CONFIG_MMC_WIDE
+	if (is_sd) {
+		resp = mmc_cmd(55, rca<<16, CMD_F_RESP);
+		resp = mmc_cmd(6, 0x02, CMD_F_RESP);
+		wide = 1;
+	}
+#endif
+
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return rc;
+}
+
+int
+mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int
+mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000)
+		return 1;
+
+	return 0;
+}
+
+#endif	/* defined(CONFIG_MMC) && defined(CONFIG_MMC_S3C) */
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/nand.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/nand.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/nand.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/nand.c	2015-01-10 16:29:28.550519392 +0530
@@ -0,0 +1,345 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if 0
+#define DEBUGN	printf
+#else
+#define DEBUGN(x, args ...) {}
+#endif
+
+#if defined(CONFIG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include <nand.h>
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+
+//#define	NF_BASE		0x4e000000
+
+//#define	NFCONF		__REGi(NF_BASE + 0x0)
+
+#if defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+
+#define NFB_BASE S3C2410_NAND_BASE
+
+#define oNFCMD		0x4
+#define	oNFADDR		0x8
+#define oNFDATA		0xc
+#define oNFSTAT		0x10
+#define NFECC0		__REGb(NF_BASE + 0x14)
+#define NFECC1		__REGb(NF_BASE + 0x15)
+#define NFECC2		__REGb(NF_BASE + 0x16)
+#define NFCONF_nFCE	(1<<11)
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#include <s3c2440.h>
+
+#define NF_BASE S3C2440_NAND_BASE
+
+#define oNFCMD		0x8
+#define oNFADDR		0xc
+#define oNFDATA		0x10
+#define oNFSTAT		0x20
+
+#define NFECC0		__REGb(NF_BASE + 0x14)
+#define NFECC1		__REGb(NF_BASE + 0x15)
+#define NFECC2		__REGb(NF_BASE + 0x16)
+
+//#define	NFCONT		__REGi(NF_BASE + 0x04)
+//#define	NFMECC0		__REGi(NF_BASE + 0x2C)
+#define NFCONF_nFCE	(1<<1)
+#define S3C2440_NFCONT_INITECC		(1<<4)
+#define S3C2440_NFCONT_MAINECCLOCK	(1<<5)
+#define nand_select()		(NFCONT &= ~(1 << 1))
+#define nand_deselect()		(NFCONT |= (1 << 1))
+#define nand_clear_RnB()	(NFSTAT |= (1 << 2))
+#define nand_detect_RB()	{ while(!(NFSTAT&(1<<2))); }
+#define nand_wait()		{ while(!(NFSTAT & 0x4)); } /* RnB_TransDectect */
+
+#endif
+
+//#define	NFCMD		__REGb(NF_BASE + oNFCMD)
+//#define	NFADDR		__REGb(NF_BASE + oNFADDR)
+//#define	NFDATA		__REGb(NF_BASE + oNFDATA)
+//#define	NFSTAT		__REGb(NF_BASE + oNFSTAT)
+
+#if defined(CONFIG_HXD8)
+static int hxd8_nand_dev_ready(struct mtd_info *mtd)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	u_int32_t val = gpio->GPCDAT;
+
+	switch (nand_curr_device) {
+		case 0:
+			return (NFSTAT & 0x01);
+		case 1:	/* RnB 3 */
+			return ((val>>6) & 0x01);
+		case 2:	/* RnB 4 */
+			return ((val>>7) & 0x01);
+		case 3:	/* RnB 2 */
+			return  ((val>>5) & 0x01);
+		default:
+			return 0;
+	}
+}
+
+/* 4G Nand flash chip select function */
+static void hxd8_nand_select_chip(struct nand_chip *this, int chip)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	if (chip == 0)
+		gpio->GPGDAT &=  ~(1 << 1);
+	else
+		gpio->GPGDAT |=  (1 << 1);
+
+	if (chip == 1)
+		gpio->GPADAT &=  ~(1 << 15);
+	else
+		gpio->GPADAT |= (1 << 15);
+
+	if (chip == 2)
+		gpio->GPADAT &=  ~(1 << 16);
+	else
+		gpio->GPADAT |=  (1 << 16);
+
+	if (chip == 3)
+		gpio->GPADAT &=  ~(1 << 14);
+	else
+		gpio->GPADAT |= (1 << 14);
+
+	/* UGLY: ew don't have mtd_info pointer, but know that
+	 * s3c24xx hwcontrol function does not use it for CLRNCE */
+	if (chip == -1)
+		this->hwcontrol(NULL, NAND_CTL_CLRNCE);
+	else
+		this->hwcontrol(NULL, NAND_CTL_SETNCE);
+}
+#endif
+
+static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	DEBUGN("hwcontrol(): 0x%02x: ", cmd);
+
+	switch (cmd) {
+	case NAND_CTL_SETNCE:
+#if defined(CONFIG_S3C2410)
+		NFCONF &= ~NFCONF_nFCE;
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#ifdef CONFIG_S3C2440_NAND_HWECC
+		NFCONT = (NFCONT & ~((1 << 5) | NFCONF_nFCE)) | S3C2440_NFCONT_INITECC;
+
+#else
+		NFCONT &= ~NFCONF_nFCE;
+#endif	
+#endif
+		DEBUGN("NFCONF=0x%08x\n", NFCONF);
+		break;
+	case NAND_CTL_CLRNCE:
+#if defined(CONFIG_S3C2410)
+		NFCONF |= NFCONF_nFCE;
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+		NFCONT &= ~NFCONF_nFCE;
+#endif
+		DEBUGN("NFCONF=0x%08x\n", NFCONF);
+		break;
+	case NAND_CTL_SETALE:
+		chip->IO_ADDR_W = NF_BASE + oNFADDR;
+		DEBUGN("SETALE\n");
+		break;
+	case NAND_CTL_SETCLE:
+		chip->IO_ADDR_W = NF_BASE + oNFCMD;
+		DEBUGN("SETCLE\n");
+		break;
+	default:
+		chip->IO_ADDR_W = NF_BASE + oNFDATA;
+		break;
+	}
+	return;
+}
+
+static int s3c2410_dev_ready(struct mtd_info *mtd)
+{
+	DEBUGN("dev_ready\n");
+	return (NFSTAT & 0x01);
+}
+
+#ifdef CONFIG_S3C2410_NAND_HWECC
+void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	DEBUGN("s3c2410_nand_enable_hwecc(%p, %d)\n", mtd ,mode);
+	NFCONF |= S3C2410_NFCONF_INITECC;
+}
+
+static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	ecc_code[0] = NFECC0;
+	ecc_code[1] = NFECC1;
+	ecc_code[2] = NFECC2;
+	DEBUGN("s3c2410_nand_calculate_hwecc(%p,): 0x%02x 0x%02x 0x%02x\n",
+		mtd , ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+static int s3c2410_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	if (read_ecc[0] == calc_ecc[0] &&
+	    read_ecc[1] == calc_ecc[1] &&
+	    read_ecc[2] == calc_ecc[2])
+		return 0;
+
+	printf("s3c2410_nand_correct_data: not implemented\n");
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_S3C2440_NAND_HWECC
+void s3c244x_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	DEBUGN("s3c244x_nand_enable_hwecc(%p, %d)\n", mtd ,mode);
+	NFCONT = (NFCONT & ~(1 << 5)) | S3C2440_NFCONT_INITECC;
+}
+
+static int s3c244x_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				      u_char *ecc_code)
+{
+	ecc_code[0] = NFECC0;
+	ecc_code[1] = NFECC1;
+	ecc_code[2] = NFECC2;
+	DEBUGN("s3c244x_nand_calculate_hwecc(%p,): 0x%02x 0x%02x 0x%02x\n",
+		mtd , ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+static int s3c244x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	if (read_ecc[0] == calc_ecc[0] &&
+	    read_ecc[1] == calc_ecc[1] &&
+	    read_ecc[2] == calc_ecc[2])
+		return 0;
+
+	printf("s3c244x_nand_correct_data: not implemented\n");
+	return -1;
+}
+#endif
+
+int board_nand_init(void) __attribute__((weak, alias("__board_nand_init")));
+
+int __board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+
+	DEBUGN("board_nand_init()\n");
+
+	clk_power->CLKCON |= (1 << 4);
+
+	/* initialize hardware */
+	twrph0 = 3; twrph1 = 0; tacls = 0;
+
+#if defined(CONFIG_S3C2410)
+	cfg = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+
+	NFCONF = cfg;
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	twrph0 = 7; twrph1 = 7; tacls = 7;
+	NFCONF = (tacls<<12)|(twrph0<<8)|(twrph1<<4)|(0<<0);
+	NFCONT = (0<<13)|(0<<12)|(0<<10)|(0<<9)|(0<<8)|(1<<6)|(1<<5)|(1<<4)|(1<<1)|(1<<0);
+#endif
+
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = nand->IO_ADDR_W = NF_BASE + oNFDATA;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+
+	/* hwcontrol always must be implemented */
+	nand->hwcontrol = s3c2410_hwcontrol;
+
+	nand->dev_ready = s3c2410_dev_ready;
+
+#ifdef CONFIG_S3C2410_NAND_HWECC
+	nand->enable_hwecc = s3c2410_nand_enable_hwecc;
+	nand->calculate_ecc = s3c2410_nand_calculate_ecc;
+	nand->correct_data = s3c2410_nand_correct_data;
+	nand->eccmode = NAND_ECC_HW3_512;
+#elif CONFIG_S3C2440_NAND_HWECC
+	nand->enable_hwecc = s3c244x_nand_enable_hwecc;
+	nand->calculate_ecc = s3c244x_nand_calculate_ecc;
+	nand->correct_data = s3c244x_nand_correct_data;
+	nand->eccmode = NAND_ECC_HW3_512;
+#else
+	nand->eccmode = NAND_ECC_SOFT;
+#endif
+
+#if defined(CONFIG_HXD8)
+	nand->dev_ready = hxd8_nand_dev_ready;
+	nand->select_chip = hxd8_nand_select_chip;
+#endif
+
+#ifdef CONFIG_S3C2410_NAND_BBT
+	nand->options = NAND_USE_FLASH_BBT | NAND_DONT_CREATE_BBT;
+#else
+	nand->options = 0;
+#endif
+
+#if defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+/*
+	nand_select();
+	nand_clear_RnB();
+	NFCMD = NAND_CMD_RESET;
+	{ volatile int i; for (i = 0; i < 10; i ++); }
+	nand_detect_RB();
+	nand_deselect();
+*/
+#endif
+
+	DEBUGN("end of nand_init\n");
+
+	return 0;
+}
+
+#else
+ #error "U-Boot legacy NAND support not available for S3C24xx"
+#endif
+#endif
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/nand_read.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/nand_read.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/nand_read.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/nand_read.c	2015-01-10 16:29:36.470519303 +0530
@@ -0,0 +1,241 @@
+/*
+ * nand_read.c: Simple NAND read functions for booting from NAND
+ *
+ * This is used by cpu/arm920/start.S assembler code,
+ * and the board-specific linker script must make sure this
+ * file is linked within the first 4kB of NAND flash.
+ *
+ * Taken from GPLv2 licensed vivi bootloader,
+ * Copyright (C) 2002 MIZI Research, Inc.
+ *
+ * Author: Hwang, Chideok <hwang@mizi.com>
+ * Date  : $Date: 2004/02/04 10:37:37 $
+ *
+ * u-boot integration and bad-block skipping (C) 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ */
+
+#include <common.h>
+#include <linux/mtd/nand.h>
+
+#ifdef CONFIG_S3C2410_NAND_BOOT
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGw(x)	(*(volatile unsigned short *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+#define NF_BASE		0x4e000000
+#if defined(CONFIG_S3C2410)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCMD		__REGb(NF_BASE + 0x4)
+#define NFADDR		__REGb(NF_BASE + 0x8)
+#define NFDATA		__REGb(NF_BASE + 0xc)
+#define NFSTAT		__REGb(NF_BASE + 0x10)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONF &= ~0x800)
+#define nand_deselect()	(NFCONF |= 0x800)
+#define nand_clear_RnB()	do {} while (0)
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCONT		__REGi(NF_BASE + 0x4)
+#define NFCMD		__REGb(NF_BASE + 0x8)
+#define NFADDR		__REGb(NF_BASE + 0xc)
+#define NFDATA		__REGb(NF_BASE + 0x10)
+#define NFDATA16	__REGw(NF_BASE + 0x10)
+#define NFSTAT		__REGb(NF_BASE + 0x20)
+#define NFSTAT_BUSY	1
+#define nand_select()	(NFCONT &= ~(1 << 1))
+#define nand_deselect()	(NFCONT |= (1 << 1))
+#define nand_clear_RnB()	(NFSTAT |= (1 << 2))
+#endif
+
+static inline void nand_wait(void)
+{
+	int i;
+
+	while (!(NFSTAT & NFSTAT_BUSY))
+		for (i=0; i<10; i++);
+}
+
+struct boot_nand_t {
+	int page_size;
+	int block_size;
+	int bad_block_offset;
+	int small_address;
+};
+
+#if 0
+#if defined(CONFIG_S3C2410) || defined(CONFIG_MINI2440)
+/* configuration for 2410 with 512byte sized flash */
+#define NAND_PAGE_SIZE		512
+#define BAD_BLOCK_OFFSET	5
+#define NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		0x4000
+#else
+/* configuration for 2440 with 2048byte sized flash */
+#define NAND_5_ADDR_CYCLE
+#define NAND_PAGE_SIZE		2048
+#define BAD_BLOCK_OFFSET	NAND_PAGE_SIZE
+#define	NAND_BLOCK_MASK		(NAND_PAGE_SIZE - 1)
+#define NAND_BLOCK_SIZE		(NAND_PAGE_SIZE * 64)
+#endif
+
+/* compile time failure in case of an invalid configuration */
+#if defined(CONFIG_S3C2410) && (NAND_PAGE_SIZE != 512)
+#error "S3C2410 does not support nand page size != 512"
+#endif
+#endif
+
+static int is_bad_block(struct boot_nand_t * nand, unsigned long i)
+{
+	unsigned char data;
+	unsigned long page_num;
+
+	nand_clear_RnB();
+	if (nand->page_size == 512) {
+		NFCMD = NAND_CMD_READOOB; /* 0x50 */
+		NFADDR = nand->bad_block_offset & 0xf;
+		NFADDR = (i >> 9) & 0xff;
+		NFADDR = (i >> 17) & 0xff;
+		if (!nand->small_address)
+			NFADDR = (i >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = i >> 11; /* addr / 2048 */
+		NFCMD = NAND_CMD_READ0;
+		NFADDR = nand->bad_block_offset & 0xff;
+		NFADDR = (nand->bad_block_offset >> 8) & 0xff;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+	data = (NFDATA & 0xff);
+	if (data != 0xff)
+		return 1;
+
+	return 0;
+}
+
+static int nand_read_page_ll(struct boot_nand_t * nand, unsigned char *buf, unsigned long addr)
+{
+	unsigned short *ptr16 = (unsigned short *)buf;
+	unsigned int i, page_num;
+
+	nand_clear_RnB();
+
+	NFCMD = NAND_CMD_READ0;
+
+	if (nand->page_size == 512) {
+		/* Write Address */
+		NFADDR = addr & 0xff;
+		NFADDR = (addr >> 9) & 0xff;
+		NFADDR = (addr >> 17) & 0xff;
+		if (!nand->small_address)
+			NFADDR = (addr >> 25) & 0xff;
+	} else if (nand->page_size == 2048) {
+		page_num = addr >> 11; /* addr / 2048 */
+		/* Write Address */
+		NFADDR = 0;
+		NFADDR = 0;
+		NFADDR = page_num & 0xff;
+		NFADDR = (page_num >> 8) & 0xff;
+		NFADDR = (page_num >> 16) & 0xff;
+		NFCMD = NAND_CMD_READSTART;
+	} else {
+		return -1;
+	}
+	nand_wait();
+
+#if defined(CONFIG_S3C2410)
+	for (i = 0; i < nand->page_size; i++) {
+		*buf = (NFDATA & 0xff);
+		buf++;
+	}
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+	for (i = 0; i < (nand->page_size>>1); i++) {
+		*ptr16 = NFDATA16;
+		ptr16++;
+	}
+#endif
+
+	return nand->page_size;
+}
+
+static unsigned short nand_read_id()
+{
+	unsigned short res = 0;
+	NFCMD = NAND_CMD_READID;
+	NFADDR = 0;
+	res = NFDATA;
+	res = (res << 8) | NFDATA;
+	return res;
+}
+
+extern unsigned int dynpart_size[];
+
+/* low level nand read function */
+int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+	int i, j;
+	unsigned short nand_id;
+	struct boot_nand_t nand;
+
+	/* chip Enable */
+	nand_select();
+	nand_clear_RnB();
+	
+	for (i = 0; i < 10; i++)
+		;
+	nand_id = nand_read_id();
+	if (0) { /* dirty little hack to detect if nand id is misread */
+		unsigned short * nid = (unsigned short *)0x31fffff0;
+		*nid = nand_id;
+	}	
+
+	if (nand_id == 0xec75 /* Samsung K90608 */ ) {
+		nand.page_size = 512;
+		nand.block_size = 16 * 1024;
+		nand.bad_block_offset = 5;
+		/* 32MiB nand only uses 3 bytes addresses */
+		nand.small_address = 1;
+	} else if (
+	    nand_id == 0xec76 || /* Samsung K91208 */ 
+	    nand_id == 0xad76 /* Hynix HY27US08121A */ ) {	
+		nand.page_size = 512;
+		nand.block_size = 16 * 1024;
+		nand.bad_block_offset = 5;
+		nand.small_address = 0;
+	} else  { /* Any other new Nand, like Samsung K9F1G08U0B */
+		nand.page_size = 2048;
+		nand.block_size = 128 * 1024;
+		nand.bad_block_offset = nand.page_size;
+	}
+	if ((start_addr & (nand.block_size-1)) || (size & ((nand.block_size-1))))
+		return -1;	/* invalid alignment */
+
+	for (i=start_addr; i < (start_addr + size);) {
+#ifdef CONFIG_S3C2410_NAND_SKIP_BAD
+		if (i & (nand.block_size-1)== 0) {
+			if (is_bad_block(&nand, i) ||
+			    is_bad_block(&nand, i + nand.page_size)) {
+				/* Bad block */
+				i += nand.block_size;
+				size += nand.block_size;
+				continue;
+			}
+		}
+#endif
+		j = nand_read_page_ll(&nand, buf, i);
+		i += j;
+		buf += j;
+	}
+
+	/* chip Disable */
+	nand_deselect();
+
+	return 0;
+}
+
+#endif /* CONFIG_S3C2410_NAND_BOOT */
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/serial.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/serial.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/serial.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/serial.c	2015-01-10 16:29:45.282519204 +0530
@@ -0,0 +1,311 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#if defined(CONFIG_S3C2400) || defined (CONFIG_S3C2410) || \
+    defined(CONFIG_S3C2440) || defined (CONFIG_S3C2442) || \
+    defined (CONFIG_TRAB)
+
+#if defined(CONFIG_S3C2400) || defined(CONFIG_TRAB)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#include <s3c2440.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_SERIAL1
+#define UART_NR	S3C24X0_UART0
+
+#elif defined(CONFIG_SERIAL2)
+# if defined(CONFIG_TRAB)
+#  error "TRAB supports only CONFIG_SERIAL1"
+# endif
+#define UART_NR	S3C24X0_UART1
+
+#elif defined(CONFIG_SERIAL3)
+# if defined(CONFIG_TRAB)
+#  #error "TRAB supports only CONFIG_SERIAL1"
+# endif
+#define UART_NR	S3C24X0_UART2
+
+#else
+#error "Bad: you didn't configure serial ..."
+#endif
+
+#if defined(CONFIG_SERIAL_MULTI)
+#include <serial.h>
+
+/* Multi serial device functions */
+#define DECLARE_S3C_SERIAL_FUNCTIONS(port) \
+    int  s3serial##port##_init (void) {\
+	return serial_init_dev(port);}\
+    void s3serial##port##_setbrg (void) {\
+	serial_setbrg_dev(port);}\
+    int  s3serial##port##_getc (void) {\
+	return serial_getc_dev(port);}\
+    int  s3serial##port##_tstc (void) {\
+	return serial_tstc_dev(port);}\
+    void s3serial##port##_putc (const char c) {\
+	serial_putc_dev(port, c);}\
+    void s3serial##port##_puts (const char *s) {\
+	serial_puts_dev(port, s);}
+
+#define INIT_S3C_SERIAL_STRUCTURE(port,name,bus) {\
+	name,\
+	bus,\
+	s3serial##port##_init,\
+	s3serial##port##_setbrg,\
+	s3serial##port##_getc,\
+	s3serial##port##_tstc,\
+	s3serial##port##_putc,\
+	s3serial##port##_puts, }
+
+#endif /* CONFIG_SERIAL_MULTI */
+
+void _serial_setbrg(const int dev_index)
+{
+	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(dev_index);
+	unsigned int reg = 0;
+	int i;
+
+	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
+	reg = get_PCLK() / (16 * gd->baudrate) - 1;
+
+	uart->UBRDIV = reg;
+	for (i = 0; i < 100; i++);
+}
+#if defined(CONFIG_SERIAL_MULTI)
+static inline void
+serial_setbrg_dev(unsigned int dev_index)
+{
+	_serial_setbrg(dev_index);
+}
+#else
+void serial_setbrg(void)
+{
+	_serial_setbrg(UART_NR);
+}
+#endif
+
+
+/* Initialise the serial port. The settings are always 8 data bits, no parity,
+ * 1 stop bit, no start bits.
+ */
+static int serial_init_dev(const int dev_index)
+{
+	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(dev_index);
+
+	/* FIFO enable, Tx/Rx FIFO clear */
+	uart->UFCON = 0x07;
+	uart->UMCON = 0x0;
+
+	/* Normal,No parity,1 stop,8 bit */
+	uart->ULCON = 0x3;
+	/*
+	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
+	 * normal,interrupt or polling
+	 */
+	uart->UCON = 0x245;
+
+#ifdef CONFIG_HWFLOW
+	uart->UMCON = 0x1; /* RTS up */
+#endif
+
+	/* FIXME: This is sooooooooooooooooooo ugly */
+#include <config.h>
+#if defined(CONFIG_GTA02_REVISION)
+	/* we need auto hw flow control on the gsm and gps port */
+	if (dev_index == 0 || dev_index == 1)
+		uart->UMCON = 0x10;
+#endif
+	_serial_setbrg(dev_index);
+
+	return (0);
+}
+
+#if !defined(CONFIG_SERIAL_MULTI)
+/* Initialise the serial port. The settings are always 8 data bits, no parity,
+ * 1 stop bit, no start bits.
+ */
+int serial_init (void)
+{
+	return serial_init_dev(UART_NR);
+}
+#endif
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+int _serial_getc (const int dev_index)
+{
+	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(dev_index);
+
+	/* wait for character to arrive */
+	while (!(uart->UTRSTAT & 0x1));
+
+	return uart->URXH & 0xff;
+}
+#if defined(CONFIG_SERIAL_MULTI)
+static inline int serial_getc_dev(unsigned int dev_index)
+{
+	return _serial_getc(dev_index);
+}
+#else
+int serial_getc (void)
+{
+	return _serial_getc(UART_NR);
+}
+#endif
+
+#ifdef CONFIG_HWFLOW
+static int hwflow = 0; /* turned off by default */
+int hwflow_onoff(int on)
+{
+	switch(on) {
+	case 0:
+	default:
+		break; /* return current */
+	case 1:
+		hwflow = 1; /* turn on */
+		break;
+	case -1:
+		hwflow = 0; /* turn off */
+		break;
+	}
+	return hwflow;
+}
+#endif
+
+#ifdef CONFIG_MODEM_SUPPORT
+static int be_quiet = 0;
+void disable_putc(void)
+{
+	be_quiet = 1;
+}
+
+void enable_putc(void)
+{
+	be_quiet = 0;
+}
+#endif
+
+
+/*
+ * Output a single byte to the serial port.
+ */
+void _serial_putc (const char c, const int dev_index)
+{
+	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(dev_index);
+#ifdef CONFIG_MODEM_SUPPORT
+	if (be_quiet)
+		return;
+#endif
+
+	/* wait for room in the tx FIFO */
+	while (!(uart->UTRSTAT & 0x2));
+
+#ifdef CONFIG_HWFLOW
+	/* Wait for CTS up */
+	while(hwflow && !(uart->UMSTAT & 0x1))
+		;
+#endif
+
+	uart->UTXH = c;
+
+	/* If \n, also do \r */
+	if (c == '\n')
+		serial_putc ('\r');
+}
+#if defined(CONFIG_SERIAL_MULTI)
+static inline void serial_putc_dev(unsigned int dev_index, const char c)
+{
+	_serial_putc(c, dev_index);
+}
+#else
+void serial_putc(const char c)
+{
+	_serial_putc(c, UART_NR);
+}
+#endif
+
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+int _serial_tstc(const int dev_index)
+{
+	S3C24X0_UART * const uart = S3C24X0_GetBase_UART(dev_index);
+
+	return uart->UTRSTAT & 0x1;
+}
+#if defined(CONFIG_SERIAL_MULTI)
+static inline int
+serial_tstc_dev(unsigned int dev_index)
+{
+	return _serial_tstc(dev_index);
+}
+#else
+int serial_tstc(void)
+{
+	return _serial_tstc(UART_NR);
+}
+#endif
+
+void _serial_puts(const char *s, const int dev_index)
+{
+	while (*s) {
+		_serial_putc (*s++, dev_index);
+	}
+}
+#if defined(CONFIG_SERIAL_MULTI)
+static inline void
+serial_puts_dev(int dev_index, const char *s)
+{
+	_serial_puts(s, dev_index);
+}
+#else
+void
+serial_puts (const char *s)
+{
+	_serial_puts(s, UART_NR);
+}
+#endif
+
+#if defined(CONFIG_SERIAL_MULTI)
+DECLARE_S3C_SERIAL_FUNCTIONS(0);
+struct serial_device s3c24xx_serial0_device =
+	INIT_S3C_SERIAL_STRUCTURE(0, "s3ser0", "S3UART1");
+DECLARE_S3C_SERIAL_FUNCTIONS(1);
+struct serial_device s3c24xx_serial1_device =
+	INIT_S3C_SERIAL_STRUCTURE(1, "s3ser1", "S3UART2");
+DECLARE_S3C_SERIAL_FUNCTIONS(2);
+struct serial_device s3c24xx_serial2_device =
+	INIT_S3C_SERIAL_STRUCTURE(2, "s3ser2", "S3UART3");
+
+#endif /* CONFIG_SERIAL_MULTI */
+
+#endif /* defined(CONFIG_S3C2400) || defined (CONFIG_S3C2410) ||
+	  defined(CONFIG_S3C2440) || defined (CONFIG_S3C2442) ||
+	  defined (CONFIG_TRAB) */
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/usb.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/usb.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/usb.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/usb.c	2015-01-10 16:30:03.034519004 +0530
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2006
+ * DENX Software Engineering <mk@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT)
+# if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410) || \
+     defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+
+#if defined(CONFIG_S3C2400)
+# include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+# include <s3c2410.h>
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+# include <s3c2440.h>
+#endif
+
+int usb_cpu_init (void)
+{
+
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/*
+	 * Set the 48 MHz UPLL clocking. Values are taken from
+	 * "PLL value selection guide", 6-23, s3c2400_UM.pdf.
+	 */
+	clk_power->UPLLCON = ((40 << 12) + (1 << 4) + 2);
+	gpio->MISCCR |= 0x8; /* 1 = use pads related USB for USB host */
+
+	/*
+	 * Enable USB host clock.
+	 */
+	clk_power->CLKCON |= (1 << 4);
+
+	return 0;
+}
+
+int usb_cpu_stop (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	/* may not want to do this */
+	clk_power->CLKCON &= ~(1 << 4);
+	return 0;
+}
+
+int usb_cpu_init_fail (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	clk_power->CLKCON &= ~(1 << 4);
+	return 0;
+}
+
+# endif /* defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410) || \
+	   defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442) */
+#endif /* defined(CONFIG_USB_OHCI) && defined(CFG_USB_OHCI_CPU_INIT) */
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.c u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.c
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.c	2015-01-10 16:30:13.150518890 +0530
@@ -0,0 +1,1691 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB on the S3C2400.
+ *
+ * (C) Copyright 2003
+ * Gary Jennejohn, DENX Software Engineering <gj@denx.de>
+ *
+ * Note: Much of this code has been derived from Linux 2.4
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+/*
+ * IMPORTANT NOTES
+ * 1 - you MUST define LITTLEENDIAN in the configuration file for the
+ *     board or this driver will NOT work!
+ * 2 - this driver is intended for use with USB Mass Storage Devices
+ *     (BBB) ONLY. There is NO support for Interrupt or Isochronous pipes!
+ */
+
+#include <common.h>
+/* #include <pci.h> no PCI on the S3C24X0 */
+
+#ifdef CONFIG_USB_OHCI
+
+#if defined(CONFIG_S3C2400)
+#include <s3c2400.h>
+#elif defined(CONFIG_S3C2410)
+#include <s3c2410.h>
+#elif defined(CONFIG_S3C2440) || defined(CONFIG_S3C2442)
+#include <s3c2440.h>
+#endif
+
+#include <malloc.h>
+#include <usb.h>
+#include "usb_ohci.h"
+
+#define OHCI_USE_NPS		/* force NoPowerSwitching mode */
+#undef OHCI_VERBOSE_DEBUG	/* not always helpful */
+
+
+/* For initializing controller (mask in an HCFS mode too) */
+#define	OHCI_CONTROL_INIT \
+	(OHCI_CTRL_CBSR & 0x3) | OHCI_CTRL_IE | OHCI_CTRL_PLE
+
+#define readl(a) (*((vu_long *)(a)))
+#define writel(a, b) (*((vu_long *)(b)) = ((vu_long)a))
+
+#define min_t(type,x,y) ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+
+#undef DEBUG
+#ifdef DEBUG
+#define dbg(format, arg...) printf("DEBUG: " format "\n", ## arg)
+#else
+#define dbg(format, arg...) do {} while(0)
+#endif /* DEBUG */
+#define err(format, arg...) printf("ERROR: " format "\n", ## arg)
+#undef SHOW_INFO
+#ifdef SHOW_INFO
+#define info(format, arg...) printf("INFO: " format "\n", ## arg)
+#else
+#define info(format, arg...) do {} while(0)
+#endif
+
+#define m16_swap(x) swap_16(x)
+#define m32_swap(x) swap_32(x)
+
+/* global ohci_t */
+static ohci_t gohci;
+/* this must be aligned to a 256 byte boundary */
+struct ohci_hcca ghcca[1];
+/* a pointer to the aligned storage */
+struct ohci_hcca *phcca;
+/* this allocates EDs for all possible endpoints */
+struct ohci_device ohci_dev;
+/* urb_priv */
+urb_priv_t urb_priv;
+/* RHSC flag */
+int got_rhsc;
+/* device which was disconnected */
+struct usb_device *devgone;
+/* flag guarding URB transation */
+int urb_finished = 0;
+
+/*-------------------------------------------------------------------------*/
+
+/* AMD-756 (D2 rev) reports corrupt register contents in some cases.
+ * The erratum (#4) description is incorrect.  AMD's workaround waits
+ * till some bits (mostly reserved) are clear; ok for all revs.
+ */
+#define OHCI_QUIRK_AMD756 0xabcd
+#define read_roothub(hc, register, mask) ({ \
+	u32 temp = readl (&hc->regs->roothub.register); \
+	if (hc->flags & OHCI_QUIRK_AMD756) \
+		while (temp & mask) \
+			temp = readl (&hc->regs->roothub.register); \
+	temp; })
+
+static u32 roothub_a (struct ohci *hc)
+	{ return read_roothub (hc, a, 0xfc0fe000); }
+static inline u32 roothub_b (struct ohci *hc)
+	{ return readl (&hc->regs->roothub.b); }
+static inline u32 roothub_status (struct ohci *hc)
+	{ return readl (&hc->regs->roothub.status); }
+static u32 roothub_portstatus (struct ohci *hc, int i)
+	{ return read_roothub (hc, portstatus [i], 0xffe0fce0); }
+
+
+/* forward declaration */
+static int hc_interrupt (void);
+static void
+td_submit_job (struct usb_device * dev, unsigned long pipe, void * buffer,
+	int transfer_len, struct devrequest * setup, urb_priv_t * urb, int interval);
+
+/*-------------------------------------------------------------------------*
+ * URB support functions
+ *-------------------------------------------------------------------------*/
+
+/* free HCD-private data associated with this URB */
+
+static void urb_free_priv (urb_priv_t * urb)
+{
+	int		i;
+	int		last;
+	struct td	* td;
+
+	last = urb->length - 1;
+	if (last >= 0) {
+		for (i = 0; i <= last; i++) {
+			td = urb->td[i];
+			if (td) {
+				td->usb_dev = NULL;
+				urb->td[i] = NULL;
+			}
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+static int sohci_get_current_frame_number (struct usb_device * dev);
+
+/* debug| print the main components of an URB
+ * small: 0) header + data packets 1) just header */
+
+static void pkt_print (struct usb_device * dev, unsigned long pipe, void * buffer,
+	int transfer_len, struct devrequest * setup, char * str, int small)
+{
+	urb_priv_t * purb = &urb_priv;
+
+	dbg("%s URB:[%4x] dev:%2d,ep:%2d-%c,type:%s,len:%d/%d stat:%#lx",
+			str,
+			sohci_get_current_frame_number (dev),
+			usb_pipedevice (pipe),
+			usb_pipeendpoint (pipe),
+			usb_pipeout (pipe)? 'O': 'I',
+			usb_pipetype (pipe) < 2? (usb_pipeint (pipe)? "INTR": "ISOC"):
+				(usb_pipecontrol (pipe)? "CTRL": "BULK"),
+			purb->actual_length,
+			transfer_len, dev->status);
+#ifdef	OHCI_VERBOSE_DEBUG
+	if (!small) {
+		int i, len;
+
+		if (usb_pipecontrol (pipe)) {
+			printf (__FILE__ ": cmd(8):");
+			for (i = 0; i < 8 ; i++)
+				printf (" %02x", ((__u8 *) setup) [i]);
+			printf ("\n");
+		}
+		if (transfer_len > 0 && buffer) {
+			printf (__FILE__ ": data(%d/%d):",
+				purb->actual_length,
+				transfer_len);
+			len = usb_pipeout (pipe)?
+					transfer_len: purb->actual_length;
+			for (i = 0; i < 16 && i < len; i++)
+				printf (" %02x", ((__u8 *) buffer) [i]);
+			printf ("%s\n", i < len? "...": "");
+		}
+	}
+#endif
+}
+
+/* just for debugging; prints non-empty branches of the int ed tree inclusive iso eds*/
+void ep_print_int_eds (ohci_t *ohci, char * str) {
+	int i, j;
+	 __u32 * ed_p;
+	for (i= 0; i < 32; i++) {
+		j = 5;
+		ed_p = &(ohci->hcca->int_table [i]);
+		if (*ed_p == 0)
+		    continue;
+		printf (__FILE__ ": %s branch int %2d(%2x):", str, i, i);
+		while (*ed_p != 0 && j--) {
+			ed_t *ed = (ed_t *)m32_swap(ed_p);
+			printf (" ed: %4x;", ed->hwINFO);
+			ed_p = &ed->hwNextED;
+		}
+		printf ("\n");
+	}
+}
+
+static void ohci_dump_intr_mask (char *label, __u32 mask)
+{
+	dbg ("%s: 0x%08x%s%s%s%s%s%s%s%s%s",
+		label,
+		mask,
+		(mask & OHCI_INTR_MIE) ? " MIE" : "",
+		(mask & OHCI_INTR_OC) ? " OC" : "",
+		(mask & OHCI_INTR_RHSC) ? " RHSC" : "",
+		(mask & OHCI_INTR_FNO) ? " FNO" : "",
+		(mask & OHCI_INTR_UE) ? " UE" : "",
+		(mask & OHCI_INTR_RD) ? " RD" : "",
+		(mask & OHCI_INTR_SF) ? " SF" : "",
+		(mask & OHCI_INTR_WDH) ? " WDH" : "",
+		(mask & OHCI_INTR_SO) ? " SO" : ""
+		);
+}
+
+static void maybe_print_eds (char *label, __u32 value)
+{
+	ed_t *edp = (ed_t *)value;
+
+	if (value) {
+		dbg ("%s %08x", label, value);
+		dbg ("%08x", edp->hwINFO);
+		dbg ("%08x", edp->hwTailP);
+		dbg ("%08x", edp->hwHeadP);
+		dbg ("%08x", edp->hwNextED);
+	}
+}
+
+static char * hcfs2string (int state)
+{
+	switch (state) {
+		case OHCI_USB_RESET:	return "reset";
+		case OHCI_USB_RESUME:	return "resume";
+		case OHCI_USB_OPER:	return "operational";
+		case OHCI_USB_SUSPEND:	return "suspend";
+	}
+	return "?";
+}
+
+/* dump control and status registers */
+static void ohci_dump_status (ohci_t *controller)
+{
+	struct ohci_regs	*regs = controller->regs;
+	__u32			temp;
+
+	temp = readl (&regs->revision) & 0xff;
+	if (temp != 0x10)
+		dbg ("spec %d.%d", (temp >> 4), (temp & 0x0f));
+
+	temp = readl (&regs->control);
+	dbg ("control: 0x%08x%s%s%s HCFS=%s%s%s%s%s CBSR=%d", temp,
+		(temp & OHCI_CTRL_RWE) ? " RWE" : "",
+		(temp & OHCI_CTRL_RWC) ? " RWC" : "",
+		(temp & OHCI_CTRL_IR) ? " IR" : "",
+		hcfs2string (temp & OHCI_CTRL_HCFS),
+		(temp & OHCI_CTRL_BLE) ? " BLE" : "",
+		(temp & OHCI_CTRL_CLE) ? " CLE" : "",
+		(temp & OHCI_CTRL_IE) ? " IE" : "",
+		(temp & OHCI_CTRL_PLE) ? " PLE" : "",
+		temp & OHCI_CTRL_CBSR
+		);
+
+	temp = readl (&regs->cmdstatus);
+	dbg ("cmdstatus: 0x%08x SOC=%d%s%s%s%s", temp,
+		(temp & OHCI_SOC) >> 16,
+		(temp & OHCI_OCR) ? " OCR" : "",
+		(temp & OHCI_BLF) ? " BLF" : "",
+		(temp & OHCI_CLF) ? " CLF" : "",
+		(temp & OHCI_HCR) ? " HCR" : ""
+		);
+
+	ohci_dump_intr_mask ("intrstatus", readl (&regs->intrstatus));
+	ohci_dump_intr_mask ("intrenable", readl (&regs->intrenable));
+
+	maybe_print_eds ("ed_periodcurrent", readl (&regs->ed_periodcurrent));
+
+	maybe_print_eds ("ed_controlhead", readl (&regs->ed_controlhead));
+	maybe_print_eds ("ed_controlcurrent", readl (&regs->ed_controlcurrent));
+
+	maybe_print_eds ("ed_bulkhead", readl (&regs->ed_bulkhead));
+	maybe_print_eds ("ed_bulkcurrent", readl (&regs->ed_bulkcurrent));
+
+	maybe_print_eds ("donehead", readl (&regs->donehead));
+}
+
+static void ohci_dump_roothub (ohci_t *controller, int verbose)
+{
+	__u32			temp, ndp, i;
+
+	temp = roothub_a (controller);
+	ndp = (temp & RH_A_NDP);
+
+	if (verbose) {
+		dbg ("roothub.a: %08x POTPGT=%d%s%s%s%s%s NDP=%d", temp,
+			((temp & RH_A_POTPGT) >> 24) & 0xff,
+			(temp & RH_A_NOCP) ? " NOCP" : "",
+			(temp & RH_A_OCPM) ? " OCPM" : "",
+			(temp & RH_A_DT) ? " DT" : "",
+			(temp & RH_A_NPS) ? " NPS" : "",
+			(temp & RH_A_PSM) ? " PSM" : "",
+			ndp
+			);
+		temp = roothub_b (controller);
+		dbg ("roothub.b: %08x PPCM=%04x DR=%04x",
+			temp,
+			(temp & RH_B_PPCM) >> 16,
+			(temp & RH_B_DR)
+			);
+		temp = roothub_status (controller);
+		dbg ("roothub.status: %08x%s%s%s%s%s%s",
+			temp,
+			(temp & RH_HS_CRWE) ? " CRWE" : "",
+			(temp & RH_HS_OCIC) ? " OCIC" : "",
+			(temp & RH_HS_LPSC) ? " LPSC" : "",
+			(temp & RH_HS_DRWE) ? " DRWE" : "",
+			(temp & RH_HS_OCI) ? " OCI" : "",
+			(temp & RH_HS_LPS) ? " LPS" : ""
+			);
+	}
+
+	for (i = 0; i < ndp; i++) {
+		temp = roothub_portstatus (controller, i);
+		dbg ("roothub.portstatus [%d] = 0x%08x%s%s%s%s%s%s%s%s%s%s%s%s",
+			i,
+			temp,
+			(temp & RH_PS_PRSC) ? " PRSC" : "",
+			(temp & RH_PS_OCIC) ? " OCIC" : "",
+			(temp & RH_PS_PSSC) ? " PSSC" : "",
+			(temp & RH_PS_PESC) ? " PESC" : "",
+			(temp & RH_PS_CSC) ? " CSC" : "",
+
+			(temp & RH_PS_LSDA) ? " LSDA" : "",
+			(temp & RH_PS_PPS) ? " PPS" : "",
+			(temp & RH_PS_PRS) ? " PRS" : "",
+			(temp & RH_PS_POCI) ? " POCI" : "",
+			(temp & RH_PS_PSS) ? " PSS" : "",
+
+			(temp & RH_PS_PES) ? " PES" : "",
+			(temp & RH_PS_CCS) ? " CCS" : ""
+			);
+	}
+}
+
+static void ohci_dump (ohci_t *controller, int verbose)
+{
+	dbg ("OHCI controller usb-%s state", controller->slot_name);
+
+	/* dumps some of the state we know about */
+	ohci_dump_status (controller);
+	if (verbose)
+		ep_print_int_eds (controller, "hcca");
+	dbg ("hcca frame #%04x", controller->hcca->frame_no);
+	ohci_dump_roothub (controller, 1);
+}
+
+
+#endif /* DEBUG */
+
+/*-------------------------------------------------------------------------*
+ * Interface functions (URB)
+ *-------------------------------------------------------------------------*/
+
+/* get a transfer request */
+
+int sohci_submit_job(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, struct devrequest *setup, int interval)
+{
+	ohci_t *ohci;
+	ed_t * ed;
+	urb_priv_t *purb_priv;
+	int i, size = 0;
+
+	ohci = &gohci;
+
+	/* when controller's hung, permit only roothub cleanup attempts
+	 * such as powering down ports */
+	if (ohci->disabled) {
+		err("sohci_submit_job: EPIPE");
+		return -1;
+	}
+
+	/* if we have an unfinished URB from previous transaction let's
+	 * fail and scream as quickly as possible so as not to corrupt
+	 * further communication */
+	if (!urb_finished) {
+		err("sohci_submit_job: URB NOT FINISHED");
+		return -1;
+	}
+	/* we're about to begin a new transaction here so mark the URB unfinished */
+	urb_finished = 0;
+
+	/* every endpoint has a ed, locate and fill it */
+	if (!(ed = ep_add_ed (dev, pipe))) {
+		err("sohci_submit_job: ENOMEM");
+		return -1;
+	}
+
+	/* for the private part of the URB we need the number of TDs (size) */
+	switch (usb_pipetype (pipe)) {
+		case PIPE_BULK:	/* one TD for every 4096 Byte */
+			size = (transfer_len - 1) / 4096 + 1;
+			break;
+		case PIPE_CONTROL: /* 1 TD for setup, 1 for ACK and 1 for every 4096 B */
+			size = (transfer_len == 0)? 2:
+						(transfer_len - 1) / 4096 + 3;
+			break;
+	}
+
+	if (size >= (N_URB_TD - 1)) {
+		err("need %d TDs, only have %d", size, N_URB_TD);
+		return -1;
+	}
+	purb_priv = &urb_priv;
+	purb_priv->pipe = pipe;
+
+	/* fill the private part of the URB */
+	purb_priv->length = size;
+	purb_priv->ed = ed;
+	purb_priv->actual_length = 0;
+
+	/* allocate the TDs */
+	/* note that td[0] was allocated in ep_add_ed */
+	for (i = 0; i < size; i++) {
+		purb_priv->td[i] = td_alloc (dev);
+		if (!purb_priv->td[i]) {
+			purb_priv->length = i;
+			urb_free_priv (purb_priv);
+			err("sohci_submit_job: ENOMEM");
+			return -1;
+		}
+	}
+
+	if (ed->state == ED_NEW || (ed->state & ED_DEL)) {
+		urb_free_priv (purb_priv);
+		err("sohci_submit_job: EINVAL");
+		return -1;
+	}
+
+	/* link the ed into a chain if is not already */
+	if (ed->state != ED_OPER)
+		ep_link (ohci, ed);
+
+	/* fill the TDs and link it to the ed */
+	td_submit_job(dev, pipe, buffer, transfer_len, setup, purb_priv, interval);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+/* tell us the current USB frame number */
+
+static int sohci_get_current_frame_number (struct usb_device *usb_dev)
+{
+	ohci_t *ohci = &gohci;
+
+	return m16_swap (ohci->hcca->frame_no);
+}
+#endif
+
+/*-------------------------------------------------------------------------*
+ * ED handling functions
+ *-------------------------------------------------------------------------*/
+
+/* link an ed into one of the HC chains */
+
+static int ep_link (ohci_t *ohci, ed_t *edi)
+{
+	volatile ed_t *ed = edi;
+
+	ed->state = ED_OPER;
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		ed->hwNextED = 0;
+		if (ohci->ed_controltail == NULL) {
+			writel (ed, &ohci->regs->ed_controlhead);
+		} else {
+			ohci->ed_controltail->hwNextED = (__u32)m32_swap (ed);
+		}
+		ed->ed_prev = ohci->ed_controltail;
+		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
+			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+			ohci->hc_control |= OHCI_CTRL_CLE;
+			writel (ohci->hc_control, &ohci->regs->control);
+		}
+		ohci->ed_controltail = edi;
+		break;
+
+	case PIPE_BULK:
+		ed->hwNextED = 0;
+		if (ohci->ed_bulktail == NULL) {
+			writel (ed, &ohci->regs->ed_bulkhead);
+		} else {
+			ohci->ed_bulktail->hwNextED = (__u32)m32_swap (ed);
+		}
+		ed->ed_prev = ohci->ed_bulktail;
+		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
+			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+			ohci->hc_control |= OHCI_CTRL_BLE;
+			writel (ohci->hc_control, &ohci->regs->control);
+		}
+		ohci->ed_bulktail = edi;
+		break;
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* unlink an ed from one of the HC chains.
+ * just the link to the ed is unlinked.
+ * the link from the ed still points to another operational ed or 0
+ * so the HC can eventually finish the processing of the unlinked ed */
+
+static int ep_unlink (ohci_t *ohci, ed_t *ed)
+{
+	ed->hwINFO |= m32_swap (OHCI_ED_SKIP);
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_CLE;
+				writel (ohci->hc_control, &ohci->regs->control);
+			}
+			writel (m32_swap (*((__u32 *)&ed->hwNextED)), &ohci->regs->ed_controlhead);
+		} else {
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_controltail == ed) {
+			ohci->ed_controltail = ed->ed_prev;
+		} else {
+			((ed_t *)m32_swap (*((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+
+	case PIPE_BULK:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_BLE;
+				writel (ohci->hc_control, &ohci->regs->control);
+			}
+			writel (m32_swap (*((__u32 *)&ed->hwNextED)), &ohci->regs->ed_bulkhead);
+		} else {
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_bulktail == ed) {
+			ohci->ed_bulktail = ed->ed_prev;
+		} else {
+			((ed_t *)m32_swap (*((__u32 *)&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+	}
+	ed->state = ED_UNLINK;
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* add/reinit an endpoint; this should be done once at the usb_set_configuration command,
+ * but the USB stack is a little bit stateless  so we do it at every transaction
+ * if the state of the ed is ED_NEW then a dummy td is added and the state is changed to ED_UNLINK
+ * in all other cases the state is left unchanged
+ * the ed info fields are setted anyway even though most of them should not change */
+
+static ed_t * ep_add_ed (struct usb_device *usb_dev, unsigned long pipe)
+{
+	td_t *td;
+	ed_t *ed_ret;
+	volatile ed_t *ed;
+
+	ed = ed_ret = &ohci_dev.ed[(usb_pipeendpoint (pipe) << 1) |
+			(usb_pipecontrol (pipe)? 0: usb_pipeout (pipe))];
+
+	if ((ed->state & ED_DEL) || (ed->state & ED_URB_DEL)) {
+		err("ep_add_ed: pending delete");
+		/* pending delete request */
+		return NULL;
+	}
+
+	if (ed->state == ED_NEW) {
+		ed->hwINFO = m32_swap (OHCI_ED_SKIP); /* skip ed */
+		/* dummy td; end of td list for ed */
+		td = td_alloc (usb_dev);
+		ed->hwTailP = (__u32)m32_swap (td);
+		ed->hwHeadP = ed->hwTailP;
+		ed->state = ED_UNLINK;
+		ed->type = usb_pipetype (pipe);
+		ohci_dev.ed_cnt++;
+	}
+
+	ed->hwINFO = m32_swap (usb_pipedevice (pipe)
+			| usb_pipeendpoint (pipe) << 7
+			| (usb_pipeisoc (pipe)? 0x8000: 0)
+			| (usb_pipecontrol (pipe)? 0: (usb_pipeout (pipe)? 0x800: 0x1000))
+			| usb_pipeslow (pipe) << 13
+			| usb_maxpacket (usb_dev, pipe) << 16);
+
+	return ed_ret;
+}
+
+/*-------------------------------------------------------------------------*
+ * TD handling functions
+ *-------------------------------------------------------------------------*/
+
+/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
+
+static void td_fill (ohci_t *ohci, unsigned int info,
+	void *data, int len,
+	struct usb_device *dev, int index, urb_priv_t *urb_priv)
+{
+	volatile td_t  *td, *td_pt;
+#ifdef OHCI_FILL_TRACE
+	int i;
+#endif
+
+	if (index > urb_priv->length) {
+		err("index > length");
+		return;
+	}
+	/* use this td as the next dummy */
+	td_pt = urb_priv->td [index];
+	td_pt->hwNextTD = 0;
+
+	/* fill the old dummy TD */
+	td = urb_priv->td [index] = (td_t *)(m32_swap (urb_priv->ed->hwTailP) & ~0xf);
+
+	td->ed = urb_priv->ed;
+	td->next_dl_td = NULL;
+	td->index = index;
+	td->data = (__u32)data;
+#ifdef OHCI_FILL_TRACE
+	if ((usb_pipetype(urb_priv->pipe) == PIPE_BULK) && usb_pipeout(urb_priv->pipe)) {
+		for (i = 0; i < len; i++)
+		printf("td->data[%d] %#2x ",i, ((unsigned char *)td->data)[i]);
+		printf("\n");
+	}
+#endif
+	if (!len)
+		data = 0;
+
+	td->hwINFO = (__u32)m32_swap (info);
+	td->hwCBP = (__u32)m32_swap (data);
+	if (data)
+		td->hwBE = (__u32)m32_swap (data + len - 1);
+	else
+		td->hwBE = 0;
+	td->hwNextTD = (__u32)m32_swap (td_pt);
+
+	/* append to queue */
+	td->ed->hwTailP = td->hwNextTD;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* prepare all TDs of a transfer */
+
+static void td_submit_job (struct usb_device *dev, unsigned long pipe, void *buffer,
+	int transfer_len, struct devrequest *setup, urb_priv_t *urb, int interval)
+{
+	ohci_t *ohci = &gohci;
+	int data_len = transfer_len;
+	void *data;
+	int cnt = 0;
+	__u32 info = 0;
+	unsigned int toggle = 0;
+
+	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle bits for reseting */
+	if(usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
+		toggle = TD_T_TOGGLE;
+	} else {
+		toggle = TD_T_DATA0;
+		usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 1);
+	}
+	urb->td_cnt = 0;
+	if (data_len)
+		data = buffer;
+	else
+		data = 0;
+
+	switch (usb_pipetype (pipe)) {
+	case PIPE_BULK:
+		info = usb_pipeout (pipe)?
+			TD_CC | TD_DP_OUT : TD_CC | TD_DP_IN ;
+		while(data_len > 4096) {
+			td_fill (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, 4096, dev, cnt, urb);
+			data += 4096; data_len -= 4096; cnt++;
+		}
+		info = usb_pipeout (pipe)?
+			TD_CC | TD_DP_OUT : TD_CC | TD_R | TD_DP_IN ;
+		td_fill (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, data_len, dev, cnt, urb);
+		cnt++;
+
+		if (!ohci->sleeping)
+			writel (OHCI_BLF, &ohci->regs->cmdstatus); /* start bulk list */
+		break;
+
+	case PIPE_CONTROL:
+		info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
+		td_fill (ohci, info, setup, 8, dev, cnt++, urb);
+		if (data_len > 0) {
+			info = usb_pipeout (pipe)?
+				TD_CC | TD_R | TD_DP_OUT | TD_T_DATA1 : TD_CC | TD_R | TD_DP_IN | TD_T_DATA1;
+			/* NOTE:  mishandles transfers >8K, some >4K */
+			td_fill (ohci, info, data, data_len, dev, cnt++, urb);
+		}
+		info = usb_pipeout (pipe)?
+			TD_CC | TD_DP_IN | TD_T_DATA1: TD_CC | TD_DP_OUT | TD_T_DATA1;
+		td_fill (ohci, info, data, 0, dev, cnt++, urb);
+		if (!ohci->sleeping)
+			writel (OHCI_CLF, &ohci->regs->cmdstatus); /* start Control list */
+		break;
+	}
+	if (urb->length != cnt)
+		dbg("TD LENGTH %d != CNT %d", urb->length, cnt);
+}
+
+/*-------------------------------------------------------------------------*
+ * Done List handling functions
+ *-------------------------------------------------------------------------*/
+
+
+/* calculate the transfer length and update the urb */
+
+static void dl_transfer_length(td_t * td)
+{
+	__u32 tdINFO, tdBE, tdCBP;
+	urb_priv_t *lurb_priv = &urb_priv;
+
+	tdINFO = m32_swap (td->hwINFO);
+	tdBE   = m32_swap (td->hwBE);
+	tdCBP  = m32_swap (td->hwCBP);
+
+
+	if (!(usb_pipetype (lurb_priv->pipe) == PIPE_CONTROL &&
+	    ((td->index == 0) || (td->index == lurb_priv->length - 1)))) {
+		if (tdBE != 0) {
+			if (td->hwCBP == 0)
+				lurb_priv->actual_length += tdBE - td->data + 1;
+			else
+				lurb_priv->actual_length += tdCBP - td->data;
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* replies to the request have to be on a FIFO basis so
+ * we reverse the reversed done-list */
+
+static td_t * dl_reverse_done_list (ohci_t *ohci)
+{
+	__u32 td_list_hc;
+	td_t *td_rev = NULL;
+	td_t *td_list = NULL;
+	urb_priv_t *lurb_priv = NULL;
+
+	td_list_hc = m32_swap (ohci->hcca->done_head) & 0xfffffff0;
+	ohci->hcca->done_head = 0;
+
+	while (td_list_hc) {
+		td_list = (td_t *)td_list_hc;
+
+		if (TD_CC_GET (m32_swap (td_list->hwINFO))) {
+			lurb_priv = &urb_priv;
+			dbg(" USB-error/status: %x : %p",
+					TD_CC_GET (m32_swap (td_list->hwINFO)), td_list);
+			if (td_list->ed->hwHeadP & m32_swap (0x1)) {
+				if (lurb_priv && ((td_list->index + 1) < lurb_priv->length)) {
+					td_list->ed->hwHeadP =
+						(lurb_priv->td[lurb_priv->length - 1]->hwNextTD & m32_swap (0xfffffff0)) |
+									(td_list->ed->hwHeadP & m32_swap (0x2));
+					lurb_priv->td_cnt += lurb_priv->length - td_list->index - 1;
+				} else
+					td_list->ed->hwHeadP &= m32_swap (0xfffffff2);
+			}
+		}
+
+		td_list->next_dl_td = td_rev;
+		td_rev = td_list;
+		td_list_hc = m32_swap (td_list->hwNextTD) & 0xfffffff0;
+	}
+
+	return td_list;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* td done list */
+static int dl_done_list (ohci_t *ohci, td_t *td_list)
+{
+	td_t *td_list_next = NULL;
+	ed_t *ed;
+	int cc = 0;
+	int stat = 0;
+	/* urb_t *urb; */
+	urb_priv_t *lurb_priv;
+	__u32 tdINFO, edHeadP, edTailP;
+
+	while (td_list) {
+		td_list_next = td_list->next_dl_td;
+
+		lurb_priv = &urb_priv;
+		tdINFO = m32_swap (td_list->hwINFO);
+
+		ed = td_list->ed;
+
+		dl_transfer_length(td_list);
+
+		/* error code of transfer */
+		cc = TD_CC_GET (tdINFO);
+		if (cc != 0) {
+			dbg("ConditionCode %#x", cc);
+			stat = cc_to_error[cc];
+		}
+
+		/* see if this done list makes for all TD's of current URB,
+		 * and mark the URB finished if so */
+		if (++(lurb_priv->td_cnt) == lurb_priv->length) {
+			if ((ed->state & (ED_OPER | ED_UNLINK)))
+				urb_finished = 1;
+			else
+				dbg("dl_done_list: strange.., ED state %x, ed->state\n");
+		} else
+			dbg("dl_done_list: processing TD %x, len %x\n", lurb_priv->td_cnt,
+				lurb_priv->length);
+
+		if (ed->state != ED_NEW) {
+			edHeadP = m32_swap (ed->hwHeadP) & 0xfffffff0;
+			edTailP = m32_swap (ed->hwTailP);
+
+			/* unlink eds if they are not busy */
+			if ((edHeadP == edTailP) && (ed->state == ED_OPER))
+				ep_unlink (ohci, ed);
+		}
+
+		td_list = td_list_next;
+	}
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*
+ * Virtual Root Hub
+ *-------------------------------------------------------------------------*/
+
+/* Device descriptor */
+static __u8 root_hub_dev_des[] =
+{
+	0x12,       /*  __u8  bLength; */
+	0x01,       /*  __u8  bDescriptorType; Device */
+	0x10,	    /*  __u16 bcdUSB; v1.1 */
+	0x01,
+	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
+	0x00,	    /*  __u8  bDeviceSubClass; */
+	0x00,       /*  __u8  bDeviceProtocol; */
+	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x00,       /*  __u16 idVendor; */
+	0x00,
+	0x00,       /*  __u16 idProduct; */
+	0x00,
+	0x00,       /*  __u16 bcdDevice; */
+	0x00,
+	0x00,       /*  __u8  iManufacturer; */
+	0x01,       /*  __u8  iProduct; */
+	0x00,       /*  __u8  iSerialNumber; */
+	0x01        /*  __u8  bNumConfigurations; */
+};
+
+
+/* Configuration descriptor */
+static __u8 root_hub_config_des[] =
+{
+	0x09,       /*  __u8  bLength; */
+	0x02,       /*  __u8  bDescriptorType; Configuration */
+	0x19,       /*  __u16 wTotalLength; */
+	0x00,
+	0x01,       /*  __u8  bNumInterfaces; */
+	0x01,       /*  __u8  bConfigurationValue; */
+	0x00,       /*  __u8  iConfiguration; */
+	0x40,       /*  __u8  bmAttributes;
+		 Bit 7: Bus-powered, 6: Self-powered, 5 Remote-wakwup, 4..0: resvd */
+	0x00,       /*  __u8  MaxPower; */
+
+	/* interface */
+	0x09,       /*  __u8  if_bLength; */
+	0x04,       /*  __u8  if_bDescriptorType; Interface */
+	0x00,       /*  __u8  if_bInterfaceNumber; */
+	0x00,       /*  __u8  if_bAlternateSetting; */
+	0x01,       /*  __u8  if_bNumEndpoints; */
+	0x09,       /*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
+	0x00,       /*  __u8  if_bInterfaceSubClass; */
+	0x00,       /*  __u8  if_bInterfaceProtocol; */
+	0x00,       /*  __u8  if_iInterface; */
+
+	/* endpoint */
+	0x07,       /*  __u8  ep_bLength; */
+	0x05,       /*  __u8  ep_bDescriptorType; Endpoint */
+	0x81,       /*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
+	0x03,       /*  __u8  ep_bmAttributes; Interrupt */
+	0x02,       /*  __u16 ep_wMaxPacketSize; ((MAX_ROOT_PORTS + 1) / 8 */
+	0x00,
+	0xff        /*  __u8  ep_bInterval; 255 ms */
+};
+
+static unsigned char root_hub_str_index0[] =
+{
+	0x04,			/*  __u8  bLength; */
+	0x03,			/*  __u8  bDescriptorType; String-descriptor */
+	0x09,			/*  __u8  lang ID */
+	0x04,			/*  __u8  lang ID */
+};
+
+static unsigned char root_hub_str_index1[] =
+{
+	28,			/*  __u8  bLength; */
+	0x03,			/*  __u8  bDescriptorType; String-descriptor */
+	'O',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'H',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'C',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'I',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	' ',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'R',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'o',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'o',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	't',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	' ',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'H',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'u',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+	'b',			/*  __u8  Unicode */
+	0,				/*  __u8  Unicode */
+};
+
+/* Hub class-specific descriptor is constructed dynamically */
+
+
+/*-------------------------------------------------------------------------*/
+
+#define OK(x) 			len = (x); break
+#ifdef DEBUG
+#define WR_RH_STAT(x) 		{info("WR:status %#8x", (x));writel((x), &gohci.regs->roothub.status);}
+#define WR_RH_PORTSTAT(x) 	{info("WR:portstatus[%d] %#8x", wIndex-1, (x));writel((x), &gohci.regs->roothub.portstatus[wIndex-1]);}
+#else
+#define WR_RH_STAT(x) 		writel((x), &gohci.regs->roothub.status)
+#define WR_RH_PORTSTAT(x) 	writel((x), &gohci.regs->roothub.portstatus[wIndex-1])
+#endif
+#define RD_RH_STAT		roothub_status(&gohci)
+#define RD_RH_PORTSTAT		roothub_portstatus(&gohci,wIndex-1)
+
+/* request to virtual root hub */
+
+int rh_check_port_status(ohci_t *controller)
+{
+	__u32 temp, ndp, i;
+	int res;
+
+	res = -1;
+	temp = roothub_a (controller);
+	ndp = (temp & RH_A_NDP);
+	for (i = 0; i < ndp; i++) {
+		temp = roothub_portstatus (controller, i);
+		/* check for a device disconnect */
+		if (((temp & (RH_PS_PESC | RH_PS_CSC)) ==
+			(RH_PS_PESC | RH_PS_CSC)) &&
+			((temp & RH_PS_CCS) == 0)) {
+			res = i;
+			break;
+		}
+	}
+	return res;
+}
+
+static int ohci_submit_rh_msg(struct usb_device *dev, unsigned long pipe,
+		void *buffer, int transfer_len, struct devrequest *cmd)
+{
+	void * data = buffer;
+	int leni = transfer_len;
+	int len = 0;
+	int stat = 0;
+	__u32 datab[4];
+	__u8 *data_buf = (__u8 *)datab;
+	__u16 bmRType_bReq;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+
+#ifdef DEBUG
+urb_priv.actual_length = 0;
+pkt_print(dev, pipe, buffer, transfer_len, cmd, "SUB(rh)", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+	if ((pipe & PIPE_INTERRUPT) == PIPE_INTERRUPT) {
+		info("Root-Hub submit IRQ: NOT implemented");
+		return 0;
+	}
+
+	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
+	wValue        = m16_swap (cmd->value);
+	wIndex        = m16_swap (cmd->index);
+	wLength       = m16_swap (cmd->length);
+
+	info("Root-Hub: adr: %2x cmd(%1x): %08x %04x %04x %04x",
+		dev->devnum, 8, bmRType_bReq, wValue, wIndex, wLength);
+
+	switch (bmRType_bReq) {
+	/* Request Destination:
+	   without flags: Device,
+	   RH_INTERFACE: interface,
+	   RH_ENDPOINT: endpoint,
+	   RH_CLASS means HUB here,
+	   RH_OTHER | RH_CLASS  almost ever means HUB_PORT here
+	*/
+
+	case RH_GET_STATUS:
+			*(__u16 *) data_buf = m16_swap (1); OK (2);
+	case RH_GET_STATUS | RH_INTERFACE:
+			*(__u16 *) data_buf = m16_swap (0); OK (2);
+	case RH_GET_STATUS | RH_ENDPOINT:
+			*(__u16 *) data_buf = m16_swap (0); OK (2);
+	case RH_GET_STATUS | RH_CLASS:
+			*(__u32 *) data_buf = m32_swap (
+				RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
+			OK (4);
+	case RH_GET_STATUS | RH_OTHER | RH_CLASS:
+			*(__u32 *) data_buf = m32_swap (RD_RH_PORTSTAT); OK (4);
+
+	case RH_CLEAR_FEATURE | RH_ENDPOINT:
+		switch (wValue) {
+			case (RH_ENDPOINT_STALL): OK (0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_CLASS:
+		switch (wValue) {
+			case RH_C_HUB_LOCAL_POWER:
+				OK(0);
+			case (RH_C_HUB_OVER_CURRENT):
+					WR_RH_STAT(RH_HS_OCIC); OK (0);
+		}
+		break;
+
+	case RH_CLEAR_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+			case (RH_PORT_ENABLE):
+					WR_RH_PORTSTAT (RH_PS_CCS ); OK (0);
+			case (RH_PORT_SUSPEND):
+					WR_RH_PORTSTAT (RH_PS_POCI); OK (0);
+			case (RH_PORT_POWER):
+					WR_RH_PORTSTAT (RH_PS_LSDA); OK (0);
+			case (RH_C_PORT_CONNECTION):
+					WR_RH_PORTSTAT (RH_PS_CSC ); OK (0);
+			case (RH_C_PORT_ENABLE):
+					WR_RH_PORTSTAT (RH_PS_PESC); OK (0);
+			case (RH_C_PORT_SUSPEND):
+					WR_RH_PORTSTAT (RH_PS_PSSC); OK (0);
+			case (RH_C_PORT_OVER_CURRENT):
+					WR_RH_PORTSTAT (RH_PS_OCIC); OK (0);
+			case (RH_C_PORT_RESET):
+					WR_RH_PORTSTAT (RH_PS_PRSC); OK (0);
+		}
+		break;
+
+	case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
+		switch (wValue) {
+			case (RH_PORT_SUSPEND):
+					WR_RH_PORTSTAT (RH_PS_PSS ); OK (0);
+			case (RH_PORT_RESET): /* BUG IN HUP CODE *********/
+					if (RD_RH_PORTSTAT & RH_PS_CCS)
+					    WR_RH_PORTSTAT (RH_PS_PRS);
+					OK (0);
+			case (RH_PORT_POWER):
+					WR_RH_PORTSTAT (RH_PS_PPS ); OK (0);
+			case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
+					if (RD_RH_PORTSTAT & RH_PS_CCS)
+					    WR_RH_PORTSTAT (RH_PS_PES );
+					OK (0);
+		}
+		break;
+
+	case RH_SET_ADDRESS: gohci.rh.devnum = wValue; OK(0);
+
+	case RH_GET_DESCRIPTOR:
+		switch ((wValue & 0xff00) >> 8) {
+			case (0x01): /* device descriptor */
+				len = min_t(unsigned int,
+					  leni,
+					  min_t(unsigned int,
+					      sizeof (root_hub_dev_des),
+					      wLength));
+				data_buf = root_hub_dev_des; OK(len);
+			case (0x02): /* configuration descriptor */
+				len = min_t(unsigned int,
+					  leni,
+					  min_t(unsigned int,
+					      sizeof (root_hub_config_des),
+					      wLength));
+				data_buf = root_hub_config_des; OK(len);
+			case (0x03): /* string descriptors */
+				if(wValue==0x0300) {
+					len = min_t(unsigned int,
+						  leni,
+						  min_t(unsigned int,
+						      sizeof (root_hub_str_index0),
+						      wLength));
+					data_buf = root_hub_str_index0;
+					OK(len);
+				}
+				if(wValue==0x0301) {
+					len = min_t(unsigned int,
+						  leni,
+						  min_t(unsigned int,
+						      sizeof (root_hub_str_index1),
+						      wLength));
+					data_buf = root_hub_str_index1;
+					OK(len);
+			}
+			default:
+				stat = USB_ST_STALLED;
+		}
+		break;
+
+	case RH_GET_DESCRIPTOR | RH_CLASS:
+	    {
+		    __u32 temp = roothub_a (&gohci);
+
+		    data_buf [0] = 9;		/* min length; */
+		    data_buf [1] = 0x29;
+		    data_buf [2] = temp & RH_A_NDP;
+		    data_buf [3] = 0;
+		    if (temp & RH_A_PSM) 	/* per-port power switching? */
+			data_buf [3] |= 0x1;
+		    if (temp & RH_A_NOCP)	/* no overcurrent reporting? */
+			data_buf [3] |= 0x10;
+		    else if (temp & RH_A_OCPM)	/* per-port overcurrent reporting? */
+			data_buf [3] |= 0x8;
+
+		    /* corresponds to data_buf[4-7] */
+		    datab [1] = 0;
+		    data_buf [5] = (temp & RH_A_POTPGT) >> 24;
+		    temp = roothub_b (&gohci);
+		    data_buf [7] = temp & RH_B_DR;
+		    if (data_buf [2] < 7) {
+			data_buf [8] = 0xff;
+		    } else {
+			data_buf [0] += 2;
+			data_buf [8] = (temp & RH_B_DR) >> 8;
+			data_buf [10] = data_buf [9] = 0xff;
+		    }
+
+		    len = min_t(unsigned int, leni,
+			      min_t(unsigned int, data_buf [0], wLength));
+		    OK (len);
+		}
+
+	case RH_GET_CONFIGURATION: 	*(__u8 *) data_buf = 0x01; OK (1);
+
+	case RH_SET_CONFIGURATION: 	WR_RH_STAT (0x10000); OK (0);
+
+	default:
+		dbg ("unsupported root hub command");
+		stat = USB_ST_STALLED;
+	}
+
+#ifdef	DEBUG
+	ohci_dump_roothub (&gohci, 1);
+#else
+	wait_ms(1);
+#endif
+
+	len = min_t(int, len, leni);
+	if (data != data_buf)
+	    memcpy (data, data_buf, len);
+	dev->act_len = len;
+	dev->status = stat;
+
+#ifdef DEBUG
+	if (transfer_len)
+		urb_priv.actual_length = transfer_len;
+	pkt_print(dev, pipe, buffer, transfer_len, cmd, "RET(rh)", 0/*usb_pipein(pipe)*/);
+#else
+	wait_ms(1);
+#endif
+
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* common code for handling submit messages - used for all but root hub */
+/* accesses. */
+int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, struct devrequest *setup, int interval)
+{
+	int stat = 0;
+	int maxsize = usb_maxpacket(dev, pipe);
+	int timeout;
+
+	/* device pulled? Shortcut the action. */
+	if (devgone == dev) {
+		dev->status = USB_ST_CRC_ERR;
+		return 0;
+	}
+
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+	if (!maxsize) {
+		err("submit_common_message: pipesize for pipe %lx is zero",
+			pipe);
+		return -1;
+	}
+
+	if (sohci_submit_job(dev, pipe, buffer, transfer_len, setup, interval) < 0) {
+		err("sohci_submit_job failed");
+		return -1;
+	}
+
+	wait_ms(10);
+	/* ohci_dump_status(&gohci); */
+
+	/* allow more time for a BULK device to react - some are slow */
+#define BULK_TO	 5000	/* timeout in milliseconds */
+	if (usb_pipetype (pipe) == PIPE_BULK)
+		timeout = BULK_TO;
+	else
+		timeout = 100;
+
+	/* wait for it to complete */
+	for (;;) {
+		/* check whether the controller is done */
+		stat = hc_interrupt();
+
+		if (stat < 0) {
+			stat = USB_ST_CRC_ERR;
+			break;
+		}
+
+		/* NOTE: since we are not interrupt driven in U-Boot and always
+		 * handle only one URB at a time, we cannot assume the
+		 * transaction finished on the first successful return from
+		 * hc_interrupt().. unless the flag for current URB is set,
+		 * meaning that all TD's to/from device got actually
+		 * transferred and processed. If the current URB is not
+		 * finished we need to re-iterate this loop so as
+		 * hc_interrupt() gets called again as there needs to be some
+		 * more TD's to process still */
+		if ((stat >= 0) && (stat != 0xff) && (urb_finished)) {
+			/* 0xff is returned for an SF-interrupt */
+			break;
+		}
+
+		if (--timeout) {
+			wait_ms(1);
+			if (!urb_finished)
+				dbg("\%");
+
+		} else {
+			err("CTL:TIMEOUT ");
+			dbg("submit_common_msg: TO status %x\n", stat);
+			stat = USB_ST_CRC_ERR;
+			urb_finished = 1;
+			break;
+		}
+	}
+
+#if 0
+	/* we got an Root Hub Status Change interrupt */
+	if (got_rhsc) {
+#ifdef DEBUG
+		ohci_dump_roothub (&gohci, 1);
+#endif
+		got_rhsc = 0;
+		/* abuse timeout */
+		timeout = rh_check_port_status(&gohci);
+		if (timeout >= 0) {
+#if 0 /* this does nothing useful, but leave it here in case that changes */
+			/* the called routine adds 1 to the passed value */
+			usb_hub_port_connect_change(gohci.rh.dev, timeout - 1);
+#endif
+			/*
+			 * XXX
+			 * This is potentially dangerous because it assumes
+			 * that only one device is ever plugged in!
+			 */
+			devgone = dev;
+		}
+	}
+#endif
+
+	dev->status = stat;
+	dev->act_len = transfer_len;
+
+#ifdef DEBUG
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "RET(ctlr)", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+
+	/* free TDs in urb_priv */
+	urb_free_priv (&urb_priv);
+	return 0;
+}
+
+/* submit routines called from usb.c */
+int submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len)
+{
+	info("submit_bulk_msg");
+	return submit_common_msg(dev, pipe, buffer, transfer_len, NULL, 0);
+}
+
+int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, struct devrequest *setup)
+{
+	int maxsize = usb_maxpacket(dev, pipe);
+
+	info("submit_control_msg");
+#ifdef DEBUG
+	urb_priv.actual_length = 0;
+	pkt_print(dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
+#else
+	wait_ms(1);
+#endif
+	if (!maxsize) {
+		err("submit_control_message: pipesize for pipe %lx is zero",
+			pipe);
+		return -1;
+	}
+	if (((pipe >> 8) & 0x7f) == gohci.rh.devnum) {
+		gohci.rh.dev = dev;
+		/* root hub - redirect */
+		return ohci_submit_rh_msg(dev, pipe, buffer, transfer_len,
+			setup);
+	}
+
+	return submit_common_msg(dev, pipe, buffer, transfer_len, setup, 0);
+}
+
+int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int transfer_len, int interval)
+{
+	info("submit_int_msg");
+	return -1;
+}
+
+/*-------------------------------------------------------------------------*
+ * HC functions
+ *-------------------------------------------------------------------------*/
+
+/* reset the HC and BUS */
+
+static int hc_reset (ohci_t *ohci)
+{
+	int timeout = 30;
+	int smm_timeout = 50; /* 0,5 sec */
+
+	if (readl (&ohci->regs->control) & OHCI_CTRL_IR) { /* SMM owns the HC */
+		writel (OHCI_OCR, &ohci->regs->cmdstatus); /* request ownership */
+		info("USB HC TakeOver from SMM");
+		while (readl (&ohci->regs->control) & OHCI_CTRL_IR) {
+			wait_ms (10);
+			if (--smm_timeout == 0) {
+				err("USB HC TakeOver failed!");
+				return -1;
+			}
+		}
+	}
+
+	/* Disable HC interrupts */
+	writel (OHCI_INTR_MIE, &ohci->regs->intrdisable);
+
+	dbg("USB HC reset_hc usb-%s: ctrl = 0x%X ;",
+		ohci->slot_name,
+		readl (&ohci->regs->control));
+
+	/* Reset USB (needed by some controllers) */
+	writel (0, &ohci->regs->control);
+
+	/* HC Reset requires max 10 us delay */
+	writel (OHCI_HCR,  &ohci->regs->cmdstatus);
+	while ((readl (&ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
+		if (--timeout == 0) {
+			err("USB HC reset timed out!");
+			return -1;
+		}
+		udelay (1);
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Start an OHCI controller, set the BUS operational
+ * enable interrupts
+ * connect the virtual root hub */
+
+static int hc_start (ohci_t * ohci)
+{
+	__u32 mask;
+	unsigned int fminterval;
+
+	ohci->disabled = 1;
+
+	/* Tell the controller where the control and bulk lists are
+	 * The lists are empty now. */
+
+	writel (0, &ohci->regs->ed_controlhead);
+	writel (0, &ohci->regs->ed_bulkhead);
+
+	writel ((__u32)ohci->hcca, &ohci->regs->hcca); /* a reset clears this */
+
+	fminterval = 0x2edf;
+	writel ((fminterval * 9) / 10, &ohci->regs->periodicstart);
+	fminterval |= ((((fminterval - 210) * 6) / 7) << 16);
+	writel (fminterval, &ohci->regs->fminterval);
+	writel (0x628, &ohci->regs->lsthresh);
+
+	/* start controller operations */
+	ohci->hc_control = OHCI_CONTROL_INIT | OHCI_USB_OPER;
+	ohci->disabled = 0;
+	writel (ohci->hc_control, &ohci->regs->control);
+
+	/* disable all interrupts */
+	mask = (OHCI_INTR_SO | OHCI_INTR_WDH | OHCI_INTR_SF | OHCI_INTR_RD |
+			OHCI_INTR_UE | OHCI_INTR_FNO | OHCI_INTR_RHSC |
+			OHCI_INTR_OC | OHCI_INTR_MIE);
+	writel (mask, &ohci->regs->intrdisable);
+	/* clear all interrupts */
+	mask &= ~OHCI_INTR_MIE;
+	writel (mask, &ohci->regs->intrstatus);
+	/* Choose the interrupts we care about now  - but w/o MIE */
+	mask = OHCI_INTR_RHSC | OHCI_INTR_UE | OHCI_INTR_WDH | OHCI_INTR_SO;
+	writel (mask, &ohci->regs->intrenable);
+
+#ifdef	OHCI_USE_NPS
+	/* required for AMD-756 and some Mac platforms */
+	writel ((roothub_a (ohci) | RH_A_NPS) & ~RH_A_PSM,
+		&ohci->regs->roothub.a);
+	writel (RH_HS_LPSC, &ohci->regs->roothub.status);
+#endif	/* OHCI_USE_NPS */
+
+#define mdelay(n) ({unsigned long msec=(n); while (msec--) udelay(1000);})
+	/* POTPGT delay is bits 24-31, in 2 ms units. */
+	mdelay ((roothub_a (ohci) >> 23) & 0x1fe);
+
+	/* connect the virtual root hub */
+	ohci->rh.devnum = 0;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* an interrupt happens */
+
+static int
+hc_interrupt (void)
+{
+	ohci_t *ohci = &gohci;
+	struct ohci_regs *regs = ohci->regs;
+	int ints;
+	int stat = -1;
+
+	if ((ohci->hcca->done_head != 0) &&
+	     !(m32_swap (ohci->hcca->done_head) & 0x01)) {
+
+		ints =  OHCI_INTR_WDH;
+
+	} else if ((ints = readl (&regs->intrstatus)) == ~(u32)0) {
+		ohci->disabled++;
+		err ("%s device removed!", ohci->slot_name);
+		return -1;
+
+	} else if ((ints &= readl (&regs->intrenable)) == 0) {
+		dbg("hc_interrupt: returning..\n");
+		return 0xff;
+	}
+
+	/* dbg("Interrupt: %x frame: %x", ints, le16_to_cpu (ohci->hcca->frame_no)); */
+
+	if (ints & OHCI_INTR_RHSC) {
+		got_rhsc = 1;
+		stat = 0xff;
+	}
+
+	if (ints & OHCI_INTR_UE) {
+		ohci->disabled++;
+		err ("OHCI Unrecoverable Error, controller usb-%s disabled",
+			ohci->slot_name);
+		/* e.g. due to PCI Master/Target Abort */
+
+#ifdef	DEBUG
+		ohci_dump (ohci, 1);
+#else
+	wait_ms(1);
+#endif
+		/* FIXME: be optimistic, hope that bug won't repeat often. */
+		/* Make some non-interrupt context restart the controller. */
+		/* Count and limit the retries though; either hardware or */
+		/* software errors can go forever... */
+		hc_reset (ohci);
+		return -1;
+	}
+
+	if (ints & OHCI_INTR_WDH) {
+		wait_ms(1);
+
+		writel (OHCI_INTR_WDH, &regs->intrdisable);
+		stat = dl_done_list (&gohci, dl_reverse_done_list (&gohci));
+		writel (OHCI_INTR_WDH, &regs->intrenable);
+	}
+
+	if (ints & OHCI_INTR_SO) {
+		dbg("USB Schedule overrun\n");
+		writel (OHCI_INTR_SO, &regs->intrenable);
+		stat = -1;
+	}
+
+	/* FIXME:  this assumes SOF (1/ms) interrupts don't get lost... */
+	if (ints & OHCI_INTR_SF) {
+		unsigned int frame = m16_swap (ohci->hcca->frame_no) & 1;
+		wait_ms(1);
+		writel (OHCI_INTR_SF, &regs->intrdisable);
+		if (ohci->ed_rm_list[frame] != NULL)
+			writel (OHCI_INTR_SF, &regs->intrenable);
+		stat = 0xff;
+	}
+
+	writel (ints, &regs->intrstatus);
+	return stat;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*-------------------------------------------------------------------------*/
+
+/* De-allocate all resources.. */
+
+static void hc_release_ohci (ohci_t *ohci)
+{
+	dbg ("USB HC release ohci usb-%s", ohci->slot_name);
+
+	if (!ohci->disabled)
+		hc_reset (ohci);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * low level initalisation routine, called from usb.c
+ */
+static char ohci_inited = 0;
+
+int usb_lowlevel_init(void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/*
+	 * Set the 48 MHz UPLL clocking. Values are taken from
+	 * "PLL value selection guide", 6-23, s3c2400_UM.pdf.
+	 */
+	clk_power->UPLLCON = ((40 << 12) + (1 << 4) + 2);
+	gpio->MISCCR |= 0x8; /* 1 = use pads related USB for USB host */
+
+	/*
+	 * Enable USB host clock.
+	 */
+	clk_power->CLKCON |= (1 << 4);
+
+	memset (&gohci, 0, sizeof (ohci_t));
+	memset (&urb_priv, 0, sizeof (urb_priv_t));
+
+	/* align the storage */
+	if ((__u32)&ghcca[0] & 0xff) {
+		err("HCCA not aligned!!");
+		return -1;
+	}
+	phcca = &ghcca[0];
+	info("aligned ghcca %p", phcca);
+	memset(&ohci_dev, 0, sizeof(struct ohci_device));
+	if ((__u32)&ohci_dev.ed[0] & 0x7) {
+		err("EDs not aligned!!");
+		return -1;
+	}
+	memset(gtd, 0, sizeof(td_t) * (NUM_TD + 1));
+	if ((__u32)gtd & 0x7) {
+		err("TDs not aligned!!");
+		return -1;
+	}
+	ptd = gtd;
+	gohci.hcca = phcca;
+	memset (phcca, 0, sizeof (struct ohci_hcca));
+
+	gohci.disabled = 1;
+	gohci.sleeping = 0;
+	gohci.irq = -1;
+	gohci.regs = (struct ohci_regs *)S3C24X0_USB_HOST_BASE;
+
+	gohci.flags = 0;
+	gohci.slot_name = "s3c2400";
+
+	if (hc_reset (&gohci) < 0) {
+		hc_release_ohci (&gohci);
+		/* Initialization failed */
+		clk_power->CLKCON &= ~(1 << 4);
+		return -1;
+	}
+
+	/* FIXME this is a second HC reset; why?? */
+	gohci.hc_control = OHCI_USB_RESET;
+	writel (gohci.hc_control, &gohci.regs->control);
+	wait_ms (10);
+
+	if (hc_start (&gohci) < 0) {
+		err ("can't start usb-%s", gohci.slot_name);
+		hc_release_ohci (&gohci);
+		/* Initialization failed */
+		clk_power->CLKCON &= ~(1 << 4);
+		return -1;
+	}
+
+#ifdef	DEBUG
+	ohci_dump (&gohci, 1);
+#else
+	wait_ms(1);
+#endif
+	ohci_inited = 1;
+	urb_finished = 1;
+
+	return 0;
+}
+
+int usb_lowlevel_stop(void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+
+	/* this gets called really early - before the controller has */
+	/* even been initialized! */
+	if (!ohci_inited)
+		return 0;
+	/* TODO release any interrupts, etc. */
+	/* call hc_release_ohci() here ? */
+	hc_reset (&gohci);
+	/* may not want to do this */
+	clk_power->CLKCON &= ~(1 << 4);
+	return 0;
+}
+
+#endif /* CONFIG_USB_OHCI */
diff -Naurp u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.h u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.h
--- u-boot-2014.04/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/arch/arm/cpu/arm920t/s3c24x0/usb_ohci.h	2015-01-10 16:30:18.242518833 +0530
@@ -0,0 +1,417 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2001 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * usb-ohci.h
+ */
+
+
+static int cc_to_error[16] = {
+
+/* mapping of the OHCI CC status to error codes */
+	/* No  Error  */               0,
+	/* CRC Error  */               USB_ST_CRC_ERR,
+	/* Bit Stuff  */               USB_ST_BIT_ERR,
+	/* Data Togg  */               USB_ST_CRC_ERR,
+	/* Stall      */               USB_ST_STALLED,
+	/* DevNotResp */               -1,
+	/* PIDCheck   */               USB_ST_BIT_ERR,
+	/* UnExpPID   */               USB_ST_BIT_ERR,
+	/* DataOver   */               USB_ST_BUF_ERR,
+	/* DataUnder  */               USB_ST_BUF_ERR,
+	/* reservd    */               -1,
+	/* reservd    */               -1,
+	/* BufferOver */               USB_ST_BUF_ERR,
+	/* BuffUnder  */               USB_ST_BUF_ERR,
+	/* Not Access */               -1,
+	/* Not Access */               -1
+};
+
+/* ED States */
+#define ED_NEW 		0x00
+#define ED_UNLINK 	0x01
+#define ED_OPER		0x02
+#define ED_DEL		0x04
+#define ED_URB_DEL  	0x08
+
+/* usb_ohci_ed */
+struct ed {
+	__u32 hwINFO;
+	__u32 hwTailP;
+	__u32 hwHeadP;
+	__u32 hwNextED;
+
+	struct ed *ed_prev;
+	__u8 int_period;
+	__u8 int_branch;
+	__u8 int_load;
+	__u8 int_interval;
+	__u8 state;
+	__u8 type;
+	__u16 last_iso;
+	struct ed *ed_rm_list;
+
+	struct usb_device *usb_dev;
+	__u32 unused[3];
+} __attribute((aligned(16)));
+typedef struct ed ed_t;
+
+
+/* TD info field */
+#define TD_CC       0xf0000000
+#define TD_CC_GET(td_p) ((td_p >>28) & 0x0f)
+#define TD_CC_SET(td_p, cc) (td_p) = ((td_p) & 0x0fffffff) | (((cc) & 0x0f) << 28)
+#define TD_EC       0x0C000000
+#define TD_T        0x03000000
+#define TD_T_DATA0  0x02000000
+#define TD_T_DATA1  0x03000000
+#define TD_T_TOGGLE 0x00000000
+#define TD_R        0x00040000
+#define TD_DI       0x00E00000
+#define TD_DI_SET(X) (((X) & 0x07)<< 21)
+#define TD_DP       0x00180000
+#define TD_DP_SETUP 0x00000000
+#define TD_DP_IN    0x00100000
+#define TD_DP_OUT   0x00080000
+
+#define TD_ISO	    0x00010000
+#define TD_DEL      0x00020000
+
+/* CC Codes */
+#define TD_CC_NOERROR      0x00
+#define TD_CC_CRC          0x01
+#define TD_CC_BITSTUFFING  0x02
+#define TD_CC_DATATOGGLEM  0x03
+#define TD_CC_STALL        0x04
+#define TD_DEVNOTRESP      0x05
+#define TD_PIDCHECKFAIL    0x06
+#define TD_UNEXPECTEDPID   0x07
+#define TD_DATAOVERRUN     0x08
+#define TD_DATAUNDERRUN    0x09
+#define TD_BUFFEROVERRUN   0x0C
+#define TD_BUFFERUNDERRUN  0x0D
+#define TD_NOTACCESSED     0x0F
+
+
+#define MAXPSW 1
+
+struct td {
+	__u32 hwINFO;
+  	__u32 hwCBP;		/* Current Buffer Pointer */
+  	__u32 hwNextTD;		/* Next TD Pointer */
+  	__u32 hwBE;		/* Memory Buffer End Pointer */
+
+  	__u8 unused;
+  	__u8 index;
+  	struct ed *ed;
+  	struct td *next_dl_td;
+	struct usb_device *usb_dev;
+	int transfer_len;
+	__u32 data;
+
+	__u32 unused2[2];
+} __attribute((aligned(32)));
+typedef struct td td_t;
+
+#define OHCI_ED_SKIP	(1 << 14)
+
+/*
+ * The HCCA (Host Controller Communications Area) is a 256 byte
+ * structure defined in the OHCI spec. that the host controller is
+ * told the base address of.  It must be 256-byte aligned.
+ */
+
+#define NUM_INTS 32	/* part of the OHCI standard */
+struct ohci_hcca {
+	__u32	int_table[NUM_INTS];	/* Interrupt ED table */
+	__u16	frame_no;		/* current frame number */
+	__u16	pad1;			/* set to 0 on each frame_no change */
+	__u32	done_head;		/* info returned for an interrupt */
+	u8		reserved_for_hc[116];
+} __attribute((aligned(256)));
+
+
+/*
+ * Maximum number of root hub ports.
+ */
+#define MAX_ROOT_PORTS	15	/* maximum OHCI root hub ports */
+
+/*
+ * This is the structure of the OHCI controller's memory mapped I/O
+ * region.  This is Memory Mapped I/O.  You must use the readl() and
+ * writel() macros defined in asm/io.h to access these!!
+ */
+struct ohci_regs {
+	/* control and status registers */
+	__u32	revision;
+	__u32	control;
+	__u32	cmdstatus;
+	__u32	intrstatus;
+	__u32	intrenable;
+	__u32	intrdisable;
+	/* memory pointers */
+	__u32	hcca;
+	__u32	ed_periodcurrent;
+	__u32	ed_controlhead;
+	__u32	ed_controlcurrent;
+	__u32	ed_bulkhead;
+	__u32	ed_bulkcurrent;
+	__u32	donehead;
+	/* frame counters */
+	__u32	fminterval;
+	__u32	fmremaining;
+	__u32	fmnumber;
+	__u32	periodicstart;
+	__u32	lsthresh;
+	/* Root hub ports */
+	struct	ohci_roothub_regs {
+		__u32	a;
+		__u32	b;
+		__u32	status;
+		__u32	portstatus[MAX_ROOT_PORTS];
+	} roothub;
+} __attribute((aligned(32)));
+
+
+/* OHCI CONTROL AND STATUS REGISTER MASKS */
+
+/*
+ * HcControl (control) register masks
+ */
+#define OHCI_CTRL_CBSR	(3 << 0)	/* control/bulk service ratio */
+#define OHCI_CTRL_PLE	(1 << 2)	/* periodic list enable */
+#define OHCI_CTRL_IE	(1 << 3)	/* isochronous enable */
+#define OHCI_CTRL_CLE	(1 << 4)	/* control list enable */
+#define OHCI_CTRL_BLE	(1 << 5)	/* bulk list enable */
+#define OHCI_CTRL_HCFS	(3 << 6)	/* host controller functional state */
+#define OHCI_CTRL_IR	(1 << 8)	/* interrupt routing */
+#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
+#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
+
+/* pre-shifted values for HCFS */
+#	define OHCI_USB_RESET	(0 << 6)
+#	define OHCI_USB_RESUME	(1 << 6)
+#	define OHCI_USB_OPER	(2 << 6)
+#	define OHCI_USB_SUSPEND	(3 << 6)
+
+/*
+ * HcCommandStatus (cmdstatus) register masks
+ */
+#define OHCI_HCR	(1 << 0)	/* host controller reset */
+#define OHCI_CLF  	(1 << 1)	/* control list filled */
+#define OHCI_BLF  	(1 << 2)	/* bulk list filled */
+#define OHCI_OCR  	(1 << 3)	/* ownership change request */
+#define OHCI_SOC  	(3 << 16)	/* scheduling overrun count */
+
+/*
+ * masks used with interrupt registers:
+ * HcInterruptStatus (intrstatus)
+ * HcInterruptEnable (intrenable)
+ * HcInterruptDisable (intrdisable)
+ */
+#define OHCI_INTR_SO	(1 << 0)	/* scheduling overrun */
+#define OHCI_INTR_WDH	(1 << 1)	/* writeback of done_head */
+#define OHCI_INTR_SF	(1 << 2)	/* start frame */
+#define OHCI_INTR_RD	(1 << 3)	/* resume detect */
+#define OHCI_INTR_UE	(1 << 4)	/* unrecoverable error */
+#define OHCI_INTR_FNO	(1 << 5)	/* frame number overflow */
+#define OHCI_INTR_RHSC	(1 << 6)	/* root hub status change */
+#define OHCI_INTR_OC	(1 << 30)	/* ownership change */
+#define OHCI_INTR_MIE	(1 << 31)	/* master interrupt enable */
+
+
+/* Virtual Root HUB */
+struct virt_root_hub {
+	int devnum; /* Address of Root Hub endpoint */
+	void *dev;  /* was urb */
+	void *int_addr;
+	int send;
+	int interval;
+};
+
+/* USB HUB CONSTANTS (not OHCI-specific; see hub.h) */
+
+/* destination of request */
+#define RH_INTERFACE               0x01
+#define RH_ENDPOINT                0x02
+#define RH_OTHER                   0x03
+
+#define RH_CLASS                   0x20
+#define RH_VENDOR                  0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS           0x0080
+#define RH_CLEAR_FEATURE        0x0100
+#define RH_SET_FEATURE          0x0300
+#define RH_SET_ADDRESS		0x0500
+#define RH_GET_DESCRIPTOR	0x0680
+#define RH_SET_DESCRIPTOR       0x0700
+#define RH_GET_CONFIGURATION	0x0880
+#define RH_SET_CONFIGURATION	0x0900
+#define RH_GET_STATE            0x0280
+#define RH_GET_INTERFACE        0x0A80
+#define RH_SET_INTERFACE        0x0B00
+#define RH_SYNC_FRAME           0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP               0x2000
+
+
+/* Hub port features */
+#define RH_PORT_CONNECTION         0x00
+#define RH_PORT_ENABLE             0x01
+#define RH_PORT_SUSPEND            0x02
+#define RH_PORT_OVER_CURRENT       0x03
+#define RH_PORT_RESET              0x04
+#define RH_PORT_POWER              0x08
+#define RH_PORT_LOW_SPEED          0x09
+
+#define RH_C_PORT_CONNECTION       0x10
+#define RH_C_PORT_ENABLE           0x11
+#define RH_C_PORT_SUSPEND          0x12
+#define RH_C_PORT_OVER_CURRENT     0x13
+#define RH_C_PORT_RESET            0x14
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER       0x00
+#define RH_C_HUB_OVER_CURRENT      0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP    0x00
+#define RH_ENDPOINT_STALL          0x01
+
+#define RH_ACK                     0x01
+#define RH_REQ_ERR                 -1
+#define RH_NACK                    0x00
+
+
+/* OHCI ROOT HUB REGISTER MASKS */
+
+/* roothub.portstatus [i] bits */
+#define RH_PS_CCS            0x00000001   	/* current connect status */
+#define RH_PS_PES            0x00000002   	/* port enable status*/
+#define RH_PS_PSS            0x00000004   	/* port suspend status */
+#define RH_PS_POCI           0x00000008   	/* port over current indicator */
+#define RH_PS_PRS            0x00000010  	/* port reset status */
+#define RH_PS_PPS            0x00000100   	/* port power status */
+#define RH_PS_LSDA           0x00000200    	/* low speed device attached */
+#define RH_PS_CSC            0x00010000 	/* connect status change */
+#define RH_PS_PESC           0x00020000   	/* port enable status change */
+#define RH_PS_PSSC           0x00040000    	/* port suspend status change */
+#define RH_PS_OCIC           0x00080000    	/* over current indicator change */
+#define RH_PS_PRSC           0x00100000   	/* port reset status change */
+
+/* roothub.status bits */
+#define RH_HS_LPS	     0x00000001		/* local power status */
+#define RH_HS_OCI	     0x00000002		/* over current indicator */
+#define RH_HS_DRWE	     0x00008000		/* device remote wakeup enable */
+#define RH_HS_LPSC	     0x00010000		/* local power status change */
+#define RH_HS_OCIC	     0x00020000		/* over current indicator change */
+#define RH_HS_CRWE	     0x80000000		/* clear remote wakeup enable */
+
+/* roothub.b masks */
+#define RH_B_DR		0x0000ffff		/* device removable flags */
+#define RH_B_PPCM	0xffff0000		/* port power control mask */
+
+/* roothub.a masks */
+#define	RH_A_NDP	(0xff << 0)		/* number of downstream ports */
+#define	RH_A_PSM	(1 << 8)		/* power switching mode */
+#define	RH_A_NPS	(1 << 9)		/* no power switching */
+#define	RH_A_DT		(1 << 10)		/* device type (mbz) */
+#define	RH_A_OCPM	(1 << 11)		/* over current protection mode */
+#define	RH_A_NOCP	(1 << 12)		/* no over current protection */
+#define	RH_A_POTPGT	(0xff << 24)		/* power on to power good time */
+
+/* urb */
+#define N_URB_TD 48
+typedef struct
+{
+	ed_t *ed;
+	__u16 length;	/* number of tds associated with this request */
+	__u16 td_cnt;	/* number of tds already serviced */
+	int   state;
+	unsigned long pipe;
+	int actual_length;
+	td_t *td[N_URB_TD];	/* list pointer to all corresponding TDs associated with this request */
+} urb_priv_t;
+#define URB_DEL 1
+
+/*
+ * This is the full ohci controller description
+ *
+ * Note how the "proper" USB information is just
+ * a subset of what the full implementation needs. (Linus)
+ */
+
+
+typedef struct ohci {
+	struct ohci_hcca *hcca;		/* hcca */
+	/*dma_addr_t hcca_dma;*/
+
+	int irq;
+	int disabled;			/* e.g. got a UE, we're hung */
+	int sleeping;
+	unsigned long flags;		/* for HC bugs */
+
+	struct ohci_regs *regs;	/* OHCI controller's memory */
+
+	ed_t *ed_rm_list[2];     /* lists of all endpoints to be removed */
+	ed_t *ed_bulktail;       /* last endpoint of bulk list */
+	ed_t *ed_controltail;    /* last endpoint of control list */
+	int intrstatus;
+	__u32 hc_control;		/* copy of the hc control reg */
+	struct usb_device *dev[32];
+	struct virt_root_hub rh;
+
+	const char	*slot_name;
+} ohci_t;
+
+#define NUM_EDS 8		/* num of preallocated endpoint descriptors */
+
+struct ohci_device {
+	ed_t 	ed[NUM_EDS];
+	int ed_cnt;
+};
+
+/* hcd */
+/* endpoint */
+static int ep_link(ohci_t * ohci, ed_t * ed);
+static int ep_unlink(ohci_t * ohci, ed_t * ed);
+static ed_t * ep_add_ed(struct usb_device * usb_dev, unsigned long pipe);
+
+/*-------------------------------------------------------------------------*/
+
+/* we need more TDs than EDs */
+#define NUM_TD 64
+
+/* +1 so we can align the storage */
+td_t gtd[NUM_TD+1];
+/* pointers to aligned storage */
+td_t *ptd;
+
+/* TDs ... */
+static inline struct td *
+td_alloc (struct usb_device *usb_dev)
+{
+	int i;
+	struct td	*td;
+
+	td = NULL;
+	for (i = 0; i < NUM_TD; i++)
+	{
+		if (ptd[i].usb_dev == NULL)
+		{
+			td = &ptd[i];
+			td->usb_dev = usb_dev;
+			break;
+		}
+	}
+
+	return td;
+}
+
+static inline void
+ed_free (struct ed *ed)
+{
+	ed->usb_dev = NULL;
+}
diff -Naurp u-boot-2014.04/board/samsung/mini2440/config.mk u-boot-2014.04.mod/board/samsung/mini2440/config.mk
--- u-boot-2014.04/board/samsung/mini2440/config.mk	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/config.mk	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2440 board with S3C2440 (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+CONFIG_USB_DFU_VENDOR=0x1457
+CONFIG_USB_DFU_PRODUCT=0x511b
+CONFIG_USB_DFU_REVISION=0x0100
+
+#
+# SMDK2440 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff -Naurp u-boot-2014.04/board/samsung/mini2440/.gitignore u-boot-2014.04.mod/board/samsung/mini2440/.gitignore
--- u-boot-2014.04/board/samsung/mini2440/.gitignore	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/.gitignore	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1 @@
+lowlevel_foo.bin
diff -Naurp u-boot-2014.04/board/samsung/mini2440/lowlevel_foo.lds u-boot-2014.04.mod/board/samsung/mini2440/lowlevel_foo.lds
--- u-boot-2014.04/board/samsung/mini2440/lowlevel_foo.lds	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/lowlevel_foo.lds	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  lowlevel_foo.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naurp u-boot-2014.04/board/samsung/mini2440/lowlevel_foo.S u-boot-2014.04.mod/board/samsung/mini2440/lowlevel_foo.S
--- u-boot-2014.04/board/samsung/mini2440/lowlevel_foo.S	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/lowlevel_foo.S	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,82 @@
+
+_start:
+	b 	reset
+undefvec:
+	b	undefvec
+swivec:
+	b	swivec
+pabtvec:
+	b	pabtvec
+dabtvec:
+	b	dabtvec
+rsvdvec:
+	b	rsvdvec
+irqvec:
+	b	irqvec
+fiqvec:
+	b	fiqvec
+
+reset:
+	/*
+	 * set the cpu to SVC32 mode
+	 */
+	mrs	r0,cpsr
+	bic	r0,r0,#0x1f
+	orr	r0,r0,#0xd3
+	msr	cpsr,r0
+
+/* turn off the watchdog */
+#define pWTCON		0x53000000
+#define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
+#define INTSUBMSK	0x4A00001C
+#define CLKDIVN	0x4C000014	/* clock divisor register */
+
+	ldr     r0, =pWTCON
+	mov     r1, #0x0
+	str     r1, [r0]
+
+	mov	r1, #0xffffffff
+	ldr	r0, =INTMSK
+	str	r1, [r0]
+	ldr	r1, =0x3ff
+	ldr	r0, =INTSUBMSK
+	str	r1, [r0]
+
+	/* FCLK:HCLK:PCLK = 1:2:4 */
+	/* default FCLK is 120 MHz ! */
+	ldr	r0, =CLKDIVN
+	mov	r1, #3
+	str	r1, [r0]
+
+	bl	cpu_init_crit
+	ldr	r0,=TEXT_BASE
+	mov	pc, r0
+
+cpu_init_crit:
+	/*
+	 * flush v4 I/D caches
+	 */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
+	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
+	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
+	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/*
+	 * before relocating, we have to setup RAM timing
+	 * because memory timing is board-dependend, you will
+	 * find a lowlevel_init.S in your board directory.
+	 */
+	mov	ip, lr
+	bl	lowlevel_init
+	mov	lr, ip
+	mov	pc, lr
+
diff -Naurp u-boot-2014.04/board/samsung/mini2440/lowlevel_init.S u-boot-2014.04.mod/board/samsung/mini2440/lowlevel_init.S
--- u-boot-2014.04/board/samsung/mini2440/lowlevel_init.S	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/lowlevel_init.S	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,197 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+#  define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
+#  define INTSUBMSK		0x4A00001C
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+#define B1_BWSCON	  	(DW32)
+#define B2_BWSCON	  	(DW16)
+#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B4_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B5_BWSCON	  	(DW16)
+#define B6_BWSCON	  	(DW32)
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x3	/*  4clk */
+#define B3_Tacp		 	0x0 /*  2clk */
+#define B3_PMC		 	0x0	/* normal */
+
+#define B4_Tacs			0x0
+#define B4_Tcos			0x3
+#define B4_Tacc			0x7
+#define B4_Tcoh			0x1
+#define B4_Tah			0x3
+#define B4_Tacp			0x0
+#define B4_PMC			0x0
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define SDRAM_MT	 	0x3	/* SDRAM */
+#define SDRAM_Trcd	 	0x0	/* 2clk */
+#define SDRAM_SCAN_9	 	0x1	/* 9bit */
+#define SDRAM_SCAN_10	 	0x2	/* 10bit */
+
+#define SDRAM_128MB	((SDRAM_MT<<15)+(SDRAM_Trcd<<2)+(SDRAM_SCAN_10))	
+#define SDRAM_64MB	((SDRAM_MT<<15)+(SDRAM_Trcd<<2)+(SDRAM_SCAN_9))	
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp		 	0x1	/* 3clk */
+#define Trc		 	0x3	/* 7clk */
+#define Tchr		 	0x0	/* unused */
+
+#define REFCNT		 	1012	/* period=10.37us, HCLK=100Mhz, (2048+1-10.37*100) */
+
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	// disable all interupts
+	mov	r1, #0xffffffff
+	ldr	r0, =INTMSK
+	str	r1, [r0]
+
+	ldr	r1, =0x7fff
+	ldr	r0, =INTSUBMSK
+	str	r1, [r0]
+
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/*
+	   SDRAM comfigured for 128MB, lets try if it works, otherwise,
+	   restart it with the smaller scan lines for 64MB
+	 */
+#if 0
+	ldr 	r1, =0x34000000		/* just outside 64MB RAM space */
+	ldr	r0, =0xdeadbeef
+	str	r0, [r1]
+	ldr	r2, [r1]
+	cmp	r2, r0
+	beq	return	
+#endif
+	ldr	r1, =BWSCON+(7*4)
+	ldr	r0, =SDRAM_64MB
+	str	r0, [r1], #4
+	str	r0, [r1]
+return:
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word SDRAM_128MB
+    .word SDRAM_128MB
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb2 /* enable burst */
+    .word 0x30
+    .word 0x30
diff -Naurp u-boot-2014.04/board/samsung/mini2440/Makefile u-boot-2014.04.mod/board/samsung/mini2440/Makefile
--- u-boot-2014.04/board/samsung/mini2440/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/Makefile	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,67 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= mini2440.o udc.o
+SOBJS	:= lowlevel_init.o
+
+.PHONY:	all
+
+all:	$(LIB) lowlevel_foo.bin
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+lowlevel_foo.o:	lowlevel_foo.S
+	$(CC) $(CFLAGS) -c -DTEXT_BASE=0x33F80000 -march=armv4 \
+	  -o lowlevel_foo.o lowlevel_foo.S
+
+lowlevel_foo:	lowlevel_foo.o lowlevel_init.o lowlevel_foo.lds
+	$(LD) -T ./lowlevel_foo.lds -Ttext 0x33f80000 -Bstatic \
+	  lowlevel_init.o lowlevel_foo.o -o lowlevel_foo
+
+lowlevel_foo.bin:	lowlevel_foo
+	$(CROSS_COMPILE)objcopy --gap-fill=0xff -O binary \
+	  lowlevel_foo lowlevel_foo.bin
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naurp u-boot-2014.04/board/samsung/mini2440/mini2440.c u-boot-2014.04.mod/board/samsung/mini2440/mini2440.c
--- u-boot-2014.04/board/samsung/mini2440/mini2440.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/mini2440.c	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,264 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ * 
+ * (C) Copyright 2009
+ * Michel Pollet <buserror@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2440.h>
+#include <video_fb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* FCLK = 405 MHz, HCLK = 101 MHz, PCLK = 50 MHz, UCLK = 48 MHz */
+#define CLKDIVN_VAL	5
+#define M_MDIV		0x7f
+#define M_PDIV		0x2
+#define M_SDIV		0x1
+
+#define U_M_MDIV	0x38
+#define U_M_PDIV	0x2
+#define U_M_SDIV	0x2
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+	clk_power->CLKDIVN = CLKDIVN_VAL;
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+	/* some delay between MPLL and UPLL */
+	delay (10);
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	gpio->GPACON = 0x007FFFFF;	/* Port A is all "special" */
+	// port B outputs reconfigured
+	gpio->GPBCON = 	
+		(0x1 <<  0) | // GPB0	OUT	TOUT0		PWM Buzzer
+		(0x2 <<  2) | // GPB1	OUT	TOUT1		LCD Backlight
+		(0x1 <<  4) | // GPB2	OUT	L3MODE
+		(0x1 <<  6) | // GBP3	OUT	L3DATA
+		(0x1 <<  8) | // GBP4	OUT	L3CLOCK
+		(0x1 << 10) | // GBP5	OUT	LED1
+		(0x1 << 12) | // GBP6	OUT	LED2
+		(0x1 << 14) | // GBP7	OUT	LED3
+		(0x1 << 16) | // GBP8	OUT	LED4
+		(0x2 << 18) | // GBP9	---	nXDACK0		CON5 EBI
+		(0x2 << 20) | // GBP10	---	nXDREQ0		CON5 EBI
+		0;
+	gpio->GPBUP	= (1 << 10) - 1; // disable pullup on all 10 pins
+	gpio->GPBDAT	= 	
+		(0 << 5) | /* turn LED 1 on */
+		(1 << 6) | /* turn LED 1 off */
+		(1 << 7) | /* turn LED 1 off */
+		(1 << 8) | /* turn LED 1 off */
+		0;
+
+	// lcd signals on C and D
+	gpio->GPCCON	= (0xAAAAAAAA &	/* all default IN but ... */
+				~(0x3 << 10)) |	/* not pin 5 ... */
+				(0x1 << 10);	/* that is output (USBD) */
+	gpio->GPCUP	= 0xFFFFFFFF;
+	gpio->GPCDAT	= 0;
+	
+	gpio->GPDCON	= 0xAAAAAAAA;
+	gpio->GPDUP	= 0xFFFFFFFF;
+	// port E is set for all it's special functions (i2c, spi etc)
+    	gpio->GPECON 	= 0xAAAAAAAA;
+	gpio->GPEUP	= 0x0000FFFF;
+
+	gpio->GPFCON 	= 
+		(0x1 <<  0) | // GPG0	EINT0	OUT
+		(0x1 <<  2) | // GPG1	EINT1	OUT
+		(0x1 <<  4) | // GPG2	EINT2	OUT
+		(0x1 <<  6) | // GPG3	EINT3	OUT
+		(0x1 <<  8) | // GPG4	EINT4	OUT
+		(0x1 << 10) | // GPG5	EINT5	OUT
+		(0x1 << 12) | // GPG6	EINT6	OUT
+		(0x0 << 14) | // GPG7	EINT7	IN	DM9000
+		0;
+	gpio->GPFDAT	= 0;
+	gpio->GPFUP	= 
+		((1 << 7) - 1) // all disabled
+		& ~( 1 << 7 ) // but for the ethernet one, we need it.
+		;
+
+	gpio->GPGCON 	=
+		(0x0 <<  0) | // GPG0	EINT8	IN	Key1
+		(0x1 <<  2) | // GPG1	EINT9	OUT		Con5
+		(0x1 <<  4) | // GPG2	EINT10	OUT
+		(0x0 <<  6) | // GPG3	EINT11	IN	Key2
+		(0x0 <<  8) | // GPG4	EINT12	IN	Smart Screen Interrupt
+		(0x0 << 10) | // GPG5	EINT13	IN	Key3
+		(0x0 << 12) | // GPG6	EINT14	IN	Key4
+		(0x0 << 14) | // GPG7	EINT15	IN	Key5
+		(0x1 << 16) | // GPG8	EINT16	OUT	nCD_SD
+		(0x1 << 18) | // GPG9	EINT17	OUT
+		(0x1 << 20) | // GPG10	EINT18	OUT
+		(0x0 << 22) | // GPG11	EINT19	IN	Key6
+		(0x0 << 24) | // GPG12	EINT18	IN	// GPG[12..15] need to be inputs
+		(0x0 << 26) | // GPG13	EINT18	IN	// hard pullups
+		(0x0 << 28) | // GPG14	EINT18	IN
+		(0x0 << 30) | // GPG15	EINT18	IN
+		0;
+	gpio->GPGUP = (1 << 15) -1;	// disable pullups for all pins
+	
+	gpio->GPHCON = 
+		(0x2 <<  0) | // GPH0	nCTS0			---
+		(0x2 <<  2) | // GPH1	nRTS0			---
+		(0x2 <<  4) | // GPH2	TXD0			---
+		(0x2 <<  6) | // GPH3	RXD0			---
+		(0x2 <<  8) | // GPH4	TXD1			---
+		(0x2 << 10) | // GPH5	RXD1			---
+		(0x2 << 12) | // GPH6	[TXD2]	nRTS1
+		(0x2 << 14) | // GPH7	[RXD2]	nCTS1
+		(0x1 << 16) | // GPH8	UEXTCLK			OUT
+		(0x1 << 18) | // GPH9	CLKOUT0			OUT
+		(0x1 << 20) | // GPH10	CLKOUT1			OUT
+		0;
+	gpio->GPHUP = (1 << 10) - 1; // disable pullups for all pins
+
+	gpio->EXTINT0=0x22222222;
+	gpio->EXTINT1=0x22222222;
+	gpio->EXTINT2=0x22222222;
+
+	/* USB Device Part */
+	/* GPC5 is reset for USB Device */
+
+	gpio->GPCDAT |= ( 1 << 5) ; 
+	udelay(20000);
+	gpio->GPCDAT &= ~( 1 << 5) ; 
+	udelay(20000);
+	gpio->GPCDAT |= ( 1 << 5) ; 
+
+	/* arch number from kernel post 2.6.28 */
+#ifndef MACH_TYPE_MINI2440
+#define MACH_TYPE_MINI2440 1999
+#endif
+	gd->bd->bi_arch_number = MACH_TYPE_MINI2440;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+
+
+#define MVAL		(0)
+#define MVAL_USED 	(0)		//0=each frame   1=rate by MVAL
+#define INVVDEN		(1)		//0=normal       1=inverted
+#define BSWP		(0)		//Byte swap control
+#define HWSWP		(1)		//Half word swap control
+
+
+//TFT 240320
+#define LCD_XSIZE_TFT_240320 	(240)	
+#define LCD_YSIZE_TFT_240320 	(320)
+
+//TFT240320
+#define HOZVAL_TFT_240320	(LCD_XSIZE_TFT_240320-1)
+#define LINEVAL_TFT_240320	(LCD_YSIZE_TFT_240320-1)
+
+//Timing parameter for NEC3.5"
+#define VBPD_240320		(3)		
+#define VFPD_240320		(10)
+#define VSPW_240320		(1)
+
+#define HBPD_240320		(5)
+#define HFPD_240320		(2)
+#define HSPW_240320		(36)
+
+#define CLKVAL_TFT_240320	(3) 	
+//FCLK=101.25MHz,HCLK=50.625MHz,VCLK=6.33MHz
+
+
+void board_video_init(GraphicDevice *pGD) 
+{ 
+    S3C24X0_LCD * const lcd = S3C24X0_GetBase_LCD(); 
+	 
+    /* FIXME: select LCM type by env variable */ 
+	 
+	/* Configuration for GTA01 LCM on QT2410 */ 
+	lcd->LCDCON1 = 0x00000378; /* CLKVAL=4, BPPMODE=16bpp, TFT, ENVID=0 */ 
+	
+//    lcd->LCDCON2 = 0x014fc141; 
+//	lcd->LCDCON3 = 0x0098ef13; 
+//	lcd->LCDCON4 = 0x00000d05; 
+	lcd->LCDCON5 = 0x00000f09; 
+
+	lcd->LCDCON2 = (VBPD_240320<<24)|(LINEVAL_TFT_240320<<14)|(VFPD_240320<<6)|(VSPW_240320); 
+	lcd->LCDCON3 = (HBPD_240320<<19)|(HOZVAL_TFT_240320<<8)|(HFPD_240320); 
+	lcd->LCDCON4 = (MVAL<<8)|(HSPW_240320); 
+	
+   
+    lcd->LPCSEL  = 0x00000000; 
+} 
+
+int dram_init (void)
+{
+	S3C24X0_MEMCTL * const mem = S3C24X0_GetBase_MEMCTL();
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	/* if the early bootloader found 128MB, lets tell the kernel */
+	if ((mem->BANKCON[6] & 0x3) == 0x2)
+		gd->bd->bi_dram[0].size = 128*1024*1024;
+	else
+		gd->bd->bi_dram[0].size = 64*1024*1024;
+
+	return 0;
+}
+
+/* The sum of all part_size[]s must equal to the NAND size, i.e., 0x4000000 */
+
+unsigned int dynpart_size[] = {
+    CFG_UBOOT_SIZE, 0x20000, 0x500000, 0xffffffff, 0 };
+char *dynpart_names[] = {
+    "u-boot", "u-boot_env", "kernel", "rootfs", NULL };
+
+
diff -Naurp u-boot-2014.04/board/samsung/mini2440/u-boot.lds u-boot-2014.04.mod/board/samsung/mini2440/u-boot.lds
--- u-boot-2014.04/board/samsung/mini2440/u-boot.lds	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/u-boot.lds	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  cpu/arm920t/s3c24x0/nand_read.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) }
+	_end = .;
+}
diff -Naurp u-boot-2014.04/board/samsung/mini2440/udc.c u-boot-2014.04.mod/board/samsung/mini2440/udc.c
--- u-boot-2014.04/board/samsung/mini2440/udc.c	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/board/samsung/mini2440/udc.c	2015-01-10 16:17:14.701322640 +0530
@@ -0,0 +1,23 @@
+
+#include <common.h>
+#include <usbdcore.h>
+#include <s3c2440.h>
+
+void udc_ctrl(enum usbd_event event, int param)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	switch (event) {
+	case UDC_CTRL_PULLUP_ENABLE:
+		if (param)
+			gpio->GPCDAT |= (1 << 5);	// GPC5
+		else
+			gpio->GPCDAT &= ~(1 << 5);
+		break;
+	case UDC_CTRL_500mA_ENABLE:
+		/* IGNORE */
+		break;
+	default:
+		break;
+	}
+}
diff -Naurp u-boot-2014.04/boards.cfg u-boot-2014.04.mod/boards.cfg
--- u-boot-2014.04/boards.cfg	2014-04-15 00:49:24.000000000 +0530
+++ u-boot-2014.04.mod/boards.cfg	2015-01-10 16:57:20.894500596 +0530
@@ -63,6 +63,8 @@ Active  arm         arm720t        -
 Active  arm         arm920t        -           armltd          integrator          integratorap_cm920t                  integratorap:CM920T                                                                                                               Linus Walleij <linus.walleij@linaro.org>
 Active  arm         arm920t        -           armltd          integrator          integratorcp_cm920t                  integratorcp:CM920T                                                                                                               Linus Walleij <linus.walleij@linaro.org>
 Active  arm         arm920t        a320        faraday         -                   a320evb                              -                                                                                                                                 Po-Yu Chuang <ratbert@faraday-tech.com>
+Active  arm	    arm920t        s3c24x0     samsung         mini2440            mini2440         
+                                    soumya-basak <soumya.basak@linaro.org>
 Active  arm         arm920t        at91        atmel           at91rm9200ek        at91rm9200ek                         -                                                                                                                                 Andreas Bießmann <andreas.devel@gmail.com>
 Active  arm         arm920t        at91        atmel           at91rm9200ek        at91rm9200ek_ram                     at91rm9200ek:RAMBOOT                                                                                                              Andreas Bießmann <andreas.devel@gmail.com>
 Active  arm         arm920t        at91        BuS             eb_cpux9k2          eb_cpux9k2                           -                                                                                                                                 Jens Scharsig <esw@bus-elektronik.de>
diff -Naurp u-boot-2014.04/include/configs/hxd8.h u-boot-2014.04.mod/include/configs/hxd8.h
--- u-boot-2014.04/include/configs/hxd8.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/include/configs/hxd8.h	2015-01-10 16:43:42.314509796 +0530
@@ -0,0 +1,279 @@
+/*
+ * (C) Copyright 2007 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * Configuation settings for the FIC HXD8
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* we want to be able to start u-boot directly from within NAND flash */
+#define CONFIG_LL_INIT_NAND_ONLY
+#define CONFIG_S3C2410_NAND_BOOT	1
+#define CONFIG_S3C2410_NAND_SKIP_BAD	1
+
+#define CFG_UBOOT_SIZE		0x40000 /* size of u-boot, for NAND loading */
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2440		1	/* in a SAMSUNG S3C2440 SoC     */
+#define CONFIG_SMDK2440		1	/* on a SAMSUNG SMDK2440 Board  */
+#define CONFIG_HXD8		1	/* on a FIC HXD8 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	16934400/* the HXD8 has this input clock */
+
+
+#define USE_920T_MMU		1
+#define CONFIG_USE_IRQ		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 2048*1024)
+					/* >> CFG_VIDEO_LOGO_MAX_SIZE */
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL3		1	/* we use SERIAL 3 on HXD8 */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMD_IMI
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_ENV
+			/* CFG_CMD_IRQ	 | */
+#define CONFIG_CMD_BOOTD
+#define CONFIG_CMD_CONSOLE
+			/* CFG_CMD_BMP	 | */
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_ECHO
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_IMMAP
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_AUTOSCRIPT
+#define CONFIG_CMD_BSP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_MISC
+			/* CFG_CMD_USB	 | */
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_DIAG
+			/* CFG_CMD_HWFLOW | */
+#define CONFIG_CMD_SAVES
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_PORTIO
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_LICENSE
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS    	""
+#define CONFIG_BOOTCOMMAND	"setenv bootargs ${bootargs_base} ${mtdparts}; nand read.e 0x32000000 kernel; bootm 0x32000000"
+
+#define CONFIG_DOS_PARTITION	1
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	3		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"HXD8 # "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		64		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(512*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(8*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+#if 0
+#define CONFIG_USB_OHCI_NEW	1
+#define CFG_USB_OHCI_CPU_INIT	1
+#define CFG_USB_OHCI_REGS_BASE	0x49000000 /* S3C24X0_USB_HOST_BASE */
+#define CFG_USB_OHCI_SLOT_NAME	"s3c2440"
+#define CFG_USB_OHCI_MAX_ROOT_PORTS 	2
+#endif
+
+#if 1
+#define CONFIG_USB_DEVICE	1
+#define CONFIG_USB_TTY		1
+#define CFG_CONSOLE_IS_IN_ENV	1
+#define CONFIG_USBD_VENDORID 		0x1457     /* Linux/NetChip */
+#define CONFIG_USBD_PRODUCTID_GSERIAL	0x5120    /* gserial */
+#define CONFIG_USBD_PRODUCTID_CDCACM 	0x511a    /* CDC ACM */
+#define CONFIG_USBD_MANUFACTURER	"OpenMoko, Inc"
+#define CONFIG_USBD_PRODUCT_NAME	"HXD8 Bootloader " U_BOOT_VERSION
+#define CONFIG_USBD_DFU			1
+#define CONFIG_USBD_DFU_XFER_SIZE 	4096	/* 0x4000 */
+#define CONFIG_USBD_DFU_INTERFACE	2
+#endif
+#define CFG_CONSOLE_IS_IN_ENV	1
+
+#define CONFIG_EXTRA_ENV_SETTINGS 					\
+	"usbtty=cdc_acm\0"						\
+	"bootargs_base=rootfstype=jffs2 root=/dev/mtdblock4 console=ttySAC2,115200 console=tty0 loglevel=8\0" \
+	""
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x08000000 /* 128 MB */
+#define PHYS_SDRAM_RES_SIZE	0x00200000 /* 2 MB for frame buffer */
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* No NOR flash in this device */
+#define CFG_NO_FLASH		1
+
+#define CFG_ENV_SIZE		0x20000		/* 128k Total Size of Environment Sector */
+#define	CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_OFFSET_OOB   	1               /* Location of ENV stored in block 0 OOB */
+#define	CFG_PREBOOT_OVERRIDE	1	/* allow preboot from memory */
+
+#define NAND_MAX_CHIPS		3
+#define CFG_NAND_BASE		0x4e000000
+#define CFG_MAX_NAND_DEVICE	NAND_MAX_CHIPS
+#define CFG_NAND_BASE_LIST	{ CFG_NAND_BASE, CFG_NAND_BASE, CFG_NAND_BASE }
+
+#define CONFIG_MMC		1
+#define CFG_MMC_BASE		0xff000000
+
+/* EXT2 driver */
+#define CONFIG_EXT2		1
+
+#define CONFIG_FAT		1
+#define CONFIG_SUPPORT_VFAT
+
+#if 1
+/* JFFS2 driver */
+#define CONFIG_JFFS2_CMDLINE	1
+#define CONFIG_JFFS2_NAND	1
+#define CONFIG_JFFS2_NAND_DEV	0
+//#define CONFIG_JFFS2_NAND_OFF	0x634000
+//#define CONFIG_JFFS2_NAND_SIZE	0x39cc000
+#endif
+
+/* ATAG configuration */
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_REVISION_TAG		1
+#if 0
+#define CONFIG_SERIAL_TAG		1
+#endif
+
+#define CONFIG_DRIVER_S3C24X0_I2C	1
+#define CONFIG_HARD_I2C			1
+#define CFG_I2C_SPEED			400000	/* 400kHz according to PCF50606 data sheet */
+#define CFG_I2C_SLAVE			0x7f
+
+/* we have a board_late_init() function */
+#define BOARD_LATE_INIT			1
+
+#if 1
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_S3C2410
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CFG_VIDEO_LOGO_MAX_SIZE	(640*480+1024+100) /* 100 = slack */
+#define CONFIG_VIDEO_BMP_GZIP
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_CMD_UNZIP
+
+#define VIDEO_KBD_INIT_FCT	0
+#define VIDEO_TSTC_FCT		serial_tstc
+#define VIDEO_GETC_FCT		serial_getc
+
+#define LCD_VIDEO_ADDR		0x33d00000
+#endif
+
+#define CONFIG_S3C2410_NAND_BBT                1
+//#define CONFIG_S3C2410_NAND_HWECC              1
+
+#define CONFIG_DRIVER_PCF50606		1
+
+#define MTDIDS_DEFAULT	"nand0=hxd8-nand"
+#define MTPARTS_DEFAULT	"hxd8-nand:256k(u-boot),128k(u-boot_env),2M(kernel),640k(splash),0x3fd00000(jffs2)"
+#define CFG_NAND_DYNPART_MTD_KERNEL_NAME "hxd8-nand"
+#define CONFIG_NAND_DYNPART
+
+#endif	/* __CONFIG_H */
diff -Naurp u-boot-2014.04/include/configs/mini2440.h u-boot-2014.04.mod/include/configs/mini2440.h
--- u-boot-2014.04/include/configs/mini2440.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/include/configs/mini2440.h	2015-01-10 17:04:58.110495457 +0530
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2009-2010
+ * Michel Pollet <buserror@gmail.com>
+ * 
+ * Configuation settings for the MINI2440 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* If we want to start u-boot directly from within NAND flash
+ * Also use this if loading the bootloader directly via JTAG
+ * Mote that this is incompatible with NOR booting.
+ */
+//#define CONFIG_LL_INIT_NAND_ONLY	1
+
+#define CONFIG_S3C2410_NAND_BOOT	1
+#define CONFIG_S3C2410_NAND_SKIP_BAD	1
+
+#define CFG_UBOOT_SIZE		0x40000 /* size of u-boot, for NAND loading */
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2440		1	/* in a SAMSUNG S3C2440 SoC     */
+#define CONFIG_MINI2440		1	/* on a MIN2440 Board  */
+
+/*
+ * It is possible to have u-boot save it's environment in NOR, however,
+ * reember it is incompatible with booting from NAND as the NOR is not
+ * available at that point. So use this only if you use nand as storage
+ * and will never boot from it
+ */
+/* #define CONFIG_MINI2440_NOR_ENV		1 */
+
+#define CONFIG_MINI2440_OVERCLOCK 1	/* allow use of frequencies over 405Mhz */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000	/* MINI2440 has 12.0000MHz input clock */
+
+
+#define USE_920T_MMU		1
+//#define CONFIG_USE_IRQ		1	/* Needed for USB device! */
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 2048*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DRIVER_DM9000_NO_EEPROM	1
+#define CONFIG_DM9000_BASE 		0x20000300
+#define DM9000_IO 			CONFIG_DM9000_BASE
+#define DM9000_DATA			(CONFIG_DM9000_BASE+4)
+
+#define CONFIG_DRIVER_S3C24X0_I2C	1
+#if (CONFIG_DRIVER_S3C24X0_I2C)
+#define CONFIG_HARD_I2C			1
+#define CFG_I2C_SPEED			100000	/* 100kHz */
+#define CFG_I2C_SLAVE			0x7f
+
+#define CONFIG_MEGADISPLAY		1
+#endif
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on MINI2440 */
+//#define CONFIG_HWFLOW		1
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+
+#undef CONFIG_CMD_CACHE
+#undef CONFIG_CMD_DIAG
+#undef CONFIG_CMD_ELF
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_PORTIO
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_SAVES
+
+#if defined(CONFIG_DRIVER_S3C24X0_I2C)
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#endif
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS    	"root=/dev/mtdblock3 rootfstype=jffs2 console=ttySAC0,115200"
+#define CONFIG_ETHADDR	        08:08:11:18:12:27
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		10.0.0.111
+#define CONFIG_SERVERIP		10.0.0.4
+
+#define CONFIG_BOOTCOMMAND	""
+
+#define CONFIG_DOS_PARTITION	1
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"MINI2440 # "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		32		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x32000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(8*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+#if 1
+#define CONFIG_USB_OHCI_NEW	1
+#define CONFIG_CMD_USB		1
+
+#define CFG_USB_OHCI_CPU_INIT	1
+#define CFG_USB_OHCI_REGS_BASE	0x49000000 /* S3C24X0_USB_HOST_BASE */
+#define CFG_USB_OHCI_SLOT_NAME	"s3c2440"
+#define CFG_USB_OHCI_MAX_ROOT_PORTS 	2
+#endif
+
+#if 1
+#define CONFIG_USB_DEVICE	1
+#define CONFIG_USB_TTY		1
+#define CONFIG_USB_STORAGE	1
+#define CFG_CONSOLE_IS_IN_ENV	1
+#define CONFIG_USBD_VENDORID		0x1457	/* FIC */
+#define CONFIG_USBD_PRODUCTID_GSERIAL	0x5120	/* gserial */
+#define CONFIG_USBD_PRODUCTID_CDCACM	0x511b	/* SMDK2440 CDC ACM */
+#define CONFIG_USBD_MANUFACTURER	"MINI2440"
+#define CONFIG_USBD_PRODUCT_NAME	"S3C2440 Bootloader " U_BOOT_VERSION
+#define CONFIG_USBD_DFU			1
+#define CONFIG_USBD_DFU_XFER_SIZE	4096
+#define CONFIG_USBD_DFU_INTERFACE	2
+//#define CONFIG_USB_DFU_REVISION 0x0100
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+/*
+ * startup code now probes, this is no longer needed
+ */
+//#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+/*
+ * When booting from NAND, it is impossible to access the lowest addresses
+ * due to the SteppingStone being in the way. Luckily the NOR doesn't really
+ * care about the highest 16 bits of address, so we set the controlers
+ * registers to go and poke over there, instead.
+ */
+#define CFG_FLASH_BASE		(0x0000 + PHYS_FLASH_1)
+
+/*
+ * NOR FLASH organization
+ * Now uses the standard CFI interface
+ */
+#define CFG_FLASH_CFI		1
+#define CFG_FLASH_CFI_DRIVER	1
+#define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CFG_MONITOR_BASE	0x0
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	512	/* 512 * 4096 sectors, or 32 * 64k blocks */
+#define CONFIG_FLASH_SHOW_PROGRESS	1
+
+/*
+ * u-boot environmnet
+ */
+#ifndef CONFIG_MINI2440_NOR_ENV
+#define	CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_OFFSET_OOB	1	// dont define for CFG_ENV_IS_IN_FLASH
+/* This size must be the size of a common denominator for the NAND erase block */
+#define CFG_ENV_SIZE		0x20000		/* 128k Total Size of Environment Sector */
+#else
+#define CFG_ENV_IS_IN_FLASH 	1
+#define CFG_MY_ENV_OFFSET 	0X40000
+#define CFG_ENV_ADDR		(PHYS_FLASH_1 + CFG_MY_ENV_OFFSET) /* addr of environment */
+#define CFG_ENV_SIZE		0x4000		/* 16k Total Size of Environment Sector */
+#endif
+#define CFG_PREBOOT_OVERRIDE	1
+
+#define NAND_MAX_CHIPS		1
+#define CFG_NAND_BASE		0x4E000000 /* S3C2440_NAND_BASE */
+#define CFG_MAX_NAND_DEVICE	1
+
+#define CONFIG_MMC		1
+#define CONFIG_MMC_S3C	1	/* Enabling the MMC driver */
+#define CFG_MMC_BASE		0xff000000
+
+#define CONFIG_EXT2		1
+
+#define CONFIG_FAT		1
+#define CONFIG_SUPPORT_VFAT	1
+
+/* JFFS2 driver */
+#define CONFIG_JFFS2_CMDLINE	1
+#define CONFIG_JFFS2_NAND	1
+#define CONFIG_JFFS2_NAND_DEV	0
+
+/* ATAG configuration */
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_CMDLINE_TAG		1
+#if 0
+#define CONFIG_REVISION_TAG		1
+#define CONFIG_SERIAL_TAG		1
+#endif
+#define CONFIG_CMDLINE_EDITING		1
+#define CONFIG_AUTO_COMPLETE		1
+
+#define CONFIG_S3C2410_NAND_BBT		1	
+//#define CONFIG_S3C2440_NAND_HWECC	1	/* this works for generation, not verification */
+
+#define CFG_NAND_YAFFS_WRITE
+#define CFG_NAND_YAFFS1_NEW_OOB_LAYOUT
+
+#define MTDIDS_DEFAULT		"nand0=mini2440-nand"
+#define MTPDARTS_DEFAULT		"mtdparts=mtdparts=mini2440-nand:256k@0(u-boot),128k(env),5m(kernel),-(root)"
+#define CFG_NAND_DYNPART_MTD_KERNEL_NAME "mini2440-nand"
+#define CONFIG_NAND_DYNPART	1
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"usbtty=cdc_acm\0" \
+	"mtdparts=mtdparts=mini2440-nand:256k@0(u-boot),128k(env),5m(kernel),-(root)\0" \
+	"mini2440=mini2440=0tb\0" \
+	"bootargs_base=console=ttySAC0,115200 noinitrd\0" \
+	"bootargs_init=init=/sbin/init\0" \
+	"root_nand=root=/dev/mtdblock3 rootfstype=jffs2\0" \
+	"root_mmc=root=/dev/mmcblk0p2 rootdelay=2\0" \
+	"root_nfs=/mnt/nfs\0" \
+	"set_root_nfs=setenv root_nfs root=/dev/nfs rw nfsroot=${serverip}:${root_nfs}\0" \
+	"ifconfig_static=run setenv ifconfig ip=${ipaddr}:${serverip}::${netmask}:mini2440:eth0\0" \
+	"ifconfig_dhcp=run setenv ifconfig ip=dhcp\0" \
+	"ifconfig=ip=dhcp\0" \
+	"set_bootargs_mmc=setenv bootargs ${bootargs_base} ${bootargs_init} ${mini2440} ${root_mmc}\0" \
+	"set_bootargs_nand=setenv bootargs ${bootargs_base} ${bootargs_init} ${mini2440} ${root_nand}\0" \
+	"set_bootargs_nfs=run set_root_nfs\; setenv bootargs ${bootargs_base} ${bootargs_init} ${mini2440} ${root_nfs} ${ifconfig}\0" \
+	""	
+
+#endif	/* __CONFIG_H */
diff -Naurp u-boot-2014.04/include/configs/smdk2400.h u-boot-2014.04.mod/include/configs/smdk2400.h
--- u-boot-2014.04/include/configs/smdk2400.h	1970-01-01 05:30:00.000000000 +0530
+++ u-boot-2014.04.mod/include/configs/smdk2400.h	2015-01-10 16:41:49.286511066 +0530
@@ -0,0 +1,199 @@
+/*
+ * (C) Copyright 2002-2005
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ *
+ * Configuation settings for the SAMSUNG board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T core	*/
+#define CONFIG_S3C2400		1	/* in a SAMSUNG S3C2400 SoC	*/
+#define CONFIG_SMDK2400		1	/* on an SAMSUNG SMDK2400 Board */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000 /* SMDK2400 has 12 MHz input clock */
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff	*/
+
+#define CONFIG_CMDLINE_TAG	 1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_CS8900	1	/* we have a CS8900 on-board */
+#define CS8900_BASE		0x07000300 /* agrees with WIN CE PA */
+#define CS8900_BUS16		1 /* the Linux driver does accesses as shorts */
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SAMSUNG */
+
+#undef	CONFIG_HWFLOW			/* include RTS/CTS flow control support	*/
+
+#undef	CONFIG_MODEM_SUPPORT		/* enable modem initialization stuff */
+
+/*
+ * The following enables modem debugging stuff. The dbg() and
+ * 'char screen[1024]' are used for debug printfs. Unfortunately,
+ * it is usable only from BDI
+ */
+#undef CONFIG_MODEM_SUPPORT_DEBUG
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+#define	CONFIG_TIMESTAMP	1	/* Print timestamp info for images */
+
+/* Use s3c2400's RTC */
+#define CONFIG_RTC_S3C24X0	1
+
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_SNTP
+
+#if defined(CONFIG_HWFLOW)
+    #define CONFIG_CONFIG_HWFLOW
+#endif
+
+#if !defined(USE_920T_MMU)
+    #undef CONFIG_CMD_CACHE
+#endif
+
+
+#define CONFIG_BOOTDELAY	3
+#if 0
+#define CONFIG_BOOTARGS    	"root=ramfs devfs=mount console=ttySA0,9600"
+#define CONFIG_ETHADDR		08:00:3e:26:0a:5b
+#endif
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		134.98.93.36
+#define CONFIG_SERVERIP		134.98.93.22
+#if 0
+#define CONFIG_BOOTFILE		"elinos-lart"
+#define CONFIG_BOOTCOMMAND	"tftp; bootm"
+#endif
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"SMDK2400 # "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x0c000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x0e000000	/* 32 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x0cf00000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x0c000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x02000000 /* 32 MB */
+
+#define CFG_FLASH_BASE		0x00000000 /* Flash Bank #1 */
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(64)	/* max number of sectors on one chip */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+#define	CFG_ENV_IS_IN_FLASH	1
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x40000)
+#define CFG_ENV_SIZE		0x40000
+
+/* Address and size of Redundant Environment Sector	*/
+#define CFG_ENV_ADDR_REDUND	(CFG_ENV_ADDR + CFG_ENV_SIZE)
+#define CFG_ENV_SIZE_REDUND	(CFG_ENV_SIZE)
+
+#endif	/* __CONFIG_H */
